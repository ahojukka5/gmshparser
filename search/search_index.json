{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"gmshparser","text":"<p>A lightweight Python package for parsing Gmsh .msh mesh files</p> <p>Package author: Jukka Aho (@ahojukka5)</p>"},{"location":"#overview","title":"Overview","text":"<p>gmshparser is a small Python package designed to do one thing well: parse Gmsh mesh file formats. With no external dependencies and a clean API, it provides a simple stand-alone solution for importing meshes into your FEM research code.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Multiple format support: MSH 1.0, 2.0, 2.1, 2.2, 4.0, and 4.1</li> <li>\u2705 Automatic version detection: No need to specify format version</li> <li>\u2705 Zero dependencies: Pure Python implementation</li> <li>\u2705 100% test coverage: Thoroughly tested and documented</li> <li>\u2705 Command-line interface: Extract mesh data from terminal</li> <li>\u2705 Easy visualization: Built-in matplotlib helpers</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install the package:</p> <pre><code>pip install gmshparser\n</code></pre> <p>Parse a mesh file:</p> <pre><code>import gmshparser\n\nmesh = gmshparser.parse(\"mesh.msh\")\nprint(f\"Loaded mesh with {mesh.get_number_of_nodes()} nodes \"\n      f\"and {mesh.get_number_of_elements()} elements\")\n</code></pre>"},{"location":"#supported-formats","title":"Supported Formats","text":"<p>gmshparser supports all major versions of the Gmsh MSH file format:</p> Version Description Status MSH 1.0 Legacy format with <code>$NOD</code>/<code>$ELM</code> sections \u2705 Supported MSH 2.0 Standard format with <code>$MeshFormat</code> \u2705 Supported MSH 2.1 Added <code>$PhysicalNames</code> support \u2705 Supported MSH 2.2 Compatible with 2.0/2.1 \u2705 Supported MSH 4.0 Modern format with <code>$Entities</code> \u2705 Supported MSH 4.1 Latest version \u2705 Supported"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#user-guide","title":"User Guide","text":"<p>Learn how to install, use, and visualize meshes with gmshparser.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<p>Contribute to the project, understand the architecture, and write custom parsers.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Complete API documentation for all classes and functions.</p>"},{"location":"#project-links","title":"Project Links","text":"<ul> <li>Source Code: GitHub Repository</li> <li>Issue Tracker: GitHub Issues</li> <li>PyPI Package: gmshparser on PyPI</li> <li>License: MIT License</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import gmshparser\n\n# Parse mesh file\nmesh = gmshparser.parse(\"data/testmesh.msh\")\n\n# Access nodes\nfor entity in mesh.get_node_entities():\n    for node in entity.get_nodes():\n        print(f\"Node {node.get_tag()}: {node.get_coordinates()}\")\n\n# Access elements\nfor entity in mesh.get_element_entities():\n    for element in entity.get_elements():\n        print(f\"Element {element.get_tag()}: {element.get_connectivity()}\")\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are always welcome! Please see our Contributing Guide for details on how to get started.</p>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to gmshparser will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>MkDocs documentation system with Material theme</li> <li>Comprehensive user guide and developer guide</li> <li>API reference with mkdocstrings</li> <li>Test data organization in <code>testdata/</code> directory</li> <li>Git LFS support for large test files</li> <li>Quad visualization helpers (<code>get_quads</code>, <code>get_elements_2d</code>)</li> </ul>"},{"location":"about/changelog/#changed","title":"Changed","text":"<ul> <li>Migrated documentation from RST to Markdown</li> <li>Organized test data into <code>testdata/simple/</code>, <code>testdata/complex/</code>, <code>testdata/large/</code></li> <li>Updated dev dependencies: black 24.x, flake8 7.x, matplotlib 3.10</li> </ul>"},{"location":"about/changelog/#removed","title":"Removed","text":"<ul> <li>Old RST documentation files</li> <li>setup.py (Poetry-only now)</li> <li>data/ directory (moved to testdata/)</li> </ul>"},{"location":"about/changelog/#020-2025-11-16","title":"[0.2.0] - 2025-11-16","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>Support for MSH 1.0 format (legacy <code>$NOD</code>/<code>$ELM</code> sections)</li> <li>Support for MSH 2.0, 2.1, 2.2 formats</li> <li>Support for MSH 4.0, 4.1 formats</li> <li>Automatic version detection</li> <li>Version-specific parser routing</li> <li><code>VersionManager</code> for version validation</li> <li>V1 parsers (<code>NodesParserV1</code>, <code>ElementsParserV1</code>)</li> <li>V2 parsers (<code>NodesParserV2</code>, <code>ElementsParserV2</code>)</li> <li>Comprehensive test suite (34 tests, 97% coverage)</li> <li>Test files for all supported versions</li> <li>Quad visualization support</li> <li>Helper functions: <code>get_quads()</code>, <code>get_elements_2d()</code></li> </ul>"},{"location":"about/changelog/#changed_1","title":"Changed","text":"<ul> <li>Updated to Python 3.8.1+ requirement</li> <li>Upgraded pytest to 8.0+</li> <li>Improved error messages</li> </ul>"},{"location":"about/changelog/#fixed","title":"Fixed","text":"<ul> <li>MSH 1.0 parsing compatibility</li> <li>Version detection for legacy formats</li> </ul>"},{"location":"about/changelog/#010-2020-xx-xx","title":"[0.1.0] - 2020-XX-XX","text":""},{"location":"about/changelog/#added_2","title":"Added","text":"<ul> <li>Initial release</li> <li>MSH 4.1 format support</li> <li>Basic mesh parsing functionality</li> <li>Command-line interface</li> <li>Triangle visualization helpers</li> </ul>"},{"location":"about/changelog/#links","title":"Links","text":"<ul> <li>PyPI Releases</li> <li>GitHub Releases</li> <li>GitHub Commits</li> </ul>"},{"location":"about/license/","title":"License","text":"<p>gmshparser is licensed under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2020 Jukka Aho</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#what-this-means","title":"What This Means","text":"<p>The MIT License is a permissive license that allows you to:</p> <p>\u2705 Use gmshparser commercially \u2705 Modify the source code \u2705 Distribute your modified versions \u2705 Use it in proprietary software \u2705 Sublicense under different terms</p> <p>You must include the original copyright notice and license text in any substantial portions of the software.</p>"},{"location":"about/license/#dependencies","title":"Dependencies","text":"<p>gmshparser has no external dependencies. The MIT License applies only to gmshparser itself.</p>"},{"location":"about/license/#third-party-components","title":"Third-Party Components","text":"<p>gmshparser does not include any third-party components.</p>"},{"location":"about/license/#contributing","title":"Contributing","text":"<p>By contributing to gmshparser, you agree that your contributions will be licensed under the same MIT License.</p> <p>See Contributing Guide for details.</p>"},{"location":"api/helpers/","title":"Helpers API","text":"<p>Utility functions for common mesh operations.</p>"},{"location":"api/helpers/#get_triangles","title":"get_triangles()","text":"<p>Extract triangular elements from mesh for plotting.</p> <p>Example:</p> <pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nfrom gmshparser.helpers import get_triangles\n\nmesh = gmshparser.parse(\"mesh.msh\")\nX, Y, T = get_triangles(mesh)\n\nplt.triplot(X, Y, T)\nplt.show()\n</code></pre>"},{"location":"api/helpers/#gmshparser.helpers.get_triangles","title":"<code>gmshparser.helpers.get_triangles(mesh)</code>","text":"<p>Return tuple (X, Y, T) of triangular data.</p> <p>Data can be used effectively in matplotlib's <code>triplot</code>:</p> <p>X, Y, T = get_triangles(mesh) plt.triplot(X, Y, T)</p> Source code in <code>gmshparser/helpers.py</code> <pre><code>def get_triangles(mesh):\n    \"\"\"Return tuple (X, Y, T) of triangular data.\n\n    Data can be used effectively in matplotlib's `triplot`:\n\n    &gt;&gt;&gt; X, Y, T = get_triangles(mesh)\n    &gt;&gt;&gt; plt.triplot(X, Y, T)\n    \"\"\"\n    elements = {}\n    nodes = {}\n    node_ids = set()\n\n    for entity in mesh.get_element_entities():\n        eltype = entity.get_element_type()\n        if entity.get_dimension() == 2 and eltype == 2:\n            for element in entity.get_elements():\n                elid = element.get_tag()\n                elcon = element.get_connectivity()\n                elements[elid] = elcon\n                for c in elcon:\n                    node_ids.add(c)\n\n    for entity in mesh.get_node_entities():\n        for node in entity.get_nodes():\n            nid = node.get_tag()\n            if nid not in node_ids:\n                continue\n            ncoords = node.get_coordinates()\n            nodes[nid] = ncoords\n\n    invP = {}\n    X = []\n    Y = []\n\n    for i, nid in enumerate(node_ids):\n        invP[nid] = i\n        X.append(nodes[nid][0])\n        Y.append(nodes[nid][1])\n\n    T = []\n    for element in elements.values():\n        T.append([invP[c] for c in element])\n\n    return X, Y, T\n</code></pre>"},{"location":"api/helpers/#get_quads","title":"get_quads()","text":"<p>Extract quadrilateral elements from mesh.</p> <p>Example:</p> <pre><code>from gmshparser.helpers import get_quads\n\nmesh = gmshparser.parse(\"quad_mesh.msh\")\nX, Y, Q = get_quads(mesh)\n\n# Plot quads\nfor quad in Q:\n    x = [X[n-1] for n in quad] + [X[quad[0]-1]]\n    y = [Y[n-1] for n in quad] + [Y[quad[0]-1]]\n    plt.plot(x, y, 'k-')\n</code></pre>"},{"location":"api/helpers/#gmshparser.helpers.get_quads","title":"<code>gmshparser.helpers.get_quads(mesh)</code>","text":"<p>Return tuple (X, Y, Q) of quadrilateral data.</p> <p>Extracts 4-node quadrilateral elements (element type 3) from mesh. Data can be used with matplotlib's patches:</p> <p>X, Y, Q = get_quads(mesh) import matplotlib.pyplot as plt import matplotlib.patches as patches fig, ax = plt.subplots() for quad in Q:     coords = [[X[i], Y[i]] for i in quad]     polygon = patches.Polygon(coords, fill=False, edgecolor='black')     ax.add_patch(polygon)</p>"},{"location":"api/helpers/#gmshparser.helpers.get_quads--parameters","title":"Parameters","text":"<p>mesh : Mesh     Mesh object containing quadrilateral elements</p>"},{"location":"api/helpers/#gmshparser.helpers.get_quads--returns","title":"Returns","text":"<p>X : list     List of x-coordinates of nodes Y : list     List of y-coordinates of nodes Q : list     List of quadrilateral connectivity, each entry is [n0, n1, n2, n3]</p> Source code in <code>gmshparser/helpers.py</code> <pre><code>def get_quads(mesh):\n    \"\"\"Return tuple (X, Y, Q) of quadrilateral data.\n\n    Extracts 4-node quadrilateral elements (element type 3) from mesh.\n    Data can be used with matplotlib's patches:\n\n    &gt;&gt;&gt; X, Y, Q = get_quads(mesh)\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; import matplotlib.patches as patches\n    &gt;&gt;&gt; fig, ax = plt.subplots()\n    &gt;&gt;&gt; for quad in Q:\n    &gt;&gt;&gt;     coords = [[X[i], Y[i]] for i in quad]\n    &gt;&gt;&gt;     polygon = patches.Polygon(coords, fill=False, edgecolor='black')\n    &gt;&gt;&gt;     ax.add_patch(polygon)\n\n    Parameters\n    ----------\n    mesh : Mesh\n        Mesh object containing quadrilateral elements\n\n    Returns\n    -------\n    X : list\n        List of x-coordinates of nodes\n    Y : list\n        List of y-coordinates of nodes\n    Q : list\n        List of quadrilateral connectivity, each entry is [n0, n1, n2, n3]\n    \"\"\"\n    elements = {}\n    nodes = {}\n    node_ids = set()\n\n    for entity in mesh.get_element_entities():\n        eltype = entity.get_element_type()\n        if entity.get_dimension() == 2 and eltype == 3:\n            for element in entity.get_elements():\n                elid = element.get_tag()\n                elcon = element.get_connectivity()\n                elements[elid] = elcon\n                for c in elcon:\n                    node_ids.add(c)\n\n    for entity in mesh.get_node_entities():\n        for node in entity.get_nodes():\n            nid = node.get_tag()\n            if nid not in node_ids:\n                continue\n            ncoords = node.get_coordinates()\n            nodes[nid] = ncoords\n\n    invP = {}\n    X = []\n    Y = []\n\n    for i, nid in enumerate(sorted(node_ids)):\n        invP[nid] = i\n        X.append(nodes[nid][0])\n        Y.append(nodes[nid][1])\n\n    Q = []\n    for element in elements.values():\n        Q.append([invP[c] for c in element])\n\n    return X, Y, Q\n</code></pre>"},{"location":"api/helpers/#get_elements_2d","title":"get_elements_2d()","text":"<p>Extract all 2D elements (triangles and quads).</p> <p>Example:</p> <pre><code>from gmshparser.helpers import get_elements_2d\n\nmesh = gmshparser.parse(\"mixed_mesh.msh\")\nX, Y, triangles, quads = get_elements_2d(mesh)\n\nprint(f\"Found {len(triangles)} triangles and {len(quads)} quads\")\n</code></pre>"},{"location":"api/helpers/#gmshparser.helpers.get_elements_2d","title":"<code>gmshparser.helpers.get_elements_2d(mesh)</code>","text":"<p>Return 2D mesh elements (triangles and quads) for visualization.</p> <p>Extracts all 2D elements from the mesh, supporting both triangular (type 2) and quadrilateral (type 3) elements.</p>"},{"location":"api/helpers/#gmshparser.helpers.get_elements_2d--parameters","title":"Parameters","text":"<p>mesh : Mesh     Mesh object containing 2D elements</p>"},{"location":"api/helpers/#gmshparser.helpers.get_elements_2d--returns","title":"Returns","text":"<p>dict     Dictionary with keys:     - 'nodes': dict mapping node_id to (x, y) coordinates     - 'triangles': list of triangle connectivity [n0, n1, n2]     - 'quads': list of quad connectivity [n0, n1, n2, n3]     - 'node_ids': list of all node IDs used</p> Source code in <code>gmshparser/helpers.py</code> <pre><code>def get_elements_2d(mesh):\n    \"\"\"Return 2D mesh elements (triangles and quads) for visualization.\n\n    Extracts all 2D elements from the mesh, supporting both triangular\n    (type 2) and quadrilateral (type 3) elements.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        Mesh object containing 2D elements\n\n    Returns\n    -------\n    dict\n        Dictionary with keys:\n        - 'nodes': dict mapping node_id to (x, y) coordinates\n        - 'triangles': list of triangle connectivity [n0, n1, n2]\n        - 'quads': list of quad connectivity [n0, n1, n2, n3]\n        - 'node_ids': list of all node IDs used\n    \"\"\"\n    triangles = []\n    quads = []\n    nodes = {}\n    node_ids = set()\n\n    # Extract elements\n    for entity in mesh.get_element_entities():\n        eltype = entity.get_element_type()\n        if entity.get_dimension() == 2:\n            for element in entity.get_elements():\n                elcon = element.get_connectivity()\n                for c in elcon:\n                    node_ids.add(c)\n\n                if eltype == 2:  # Triangle\n                    triangles.append(elcon)\n                elif eltype == 3:  # Quad\n                    quads.append(elcon)\n\n    # Extract node coordinates\n    for entity in mesh.get_node_entities():\n        for node in entity.get_nodes():\n            nid = node.get_tag()\n            if nid in node_ids:\n                ncoords = node.get_coordinates()\n                nodes[nid] = (ncoords[0], ncoords[1])\n\n    return {\n        \"nodes\": nodes,\n        \"triangles\": triangles,\n        \"quads\": quads,\n        \"node_ids\": sorted(node_ids),\n    }\n</code></pre>"},{"location":"api/helpers/#utility-functions","title":"Utility Functions","text":""},{"location":"api/helpers/#parse_ints","title":"parse_ints()","text":"<p>Parse space-separated integers from string.</p>"},{"location":"api/helpers/#parse_floats","title":"parse_floats()","text":"<p>Parse space-separated floats from string.</p>"},{"location":"api/helpers/#see-also","title":"See Also","text":"<ul> <li>Visualization Guide</li> <li>Basic Usage</li> </ul>"},{"location":"api/mesh/","title":"Mesh API","text":""},{"location":"api/mesh/#gmshparser.mesh.Mesh","title":"<code>gmshparser.mesh.Mesh</code>","text":"<p>               Bases: <code>object</code></p> <p>Mesh is the main class of the package.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>class Mesh(object):\n    \"\"\"Mesh is the main class of the package.\"\"\"\n\n    def __init__(self):\n        self.name_ = \"New Mesh\"\n        self.version_ = None  # Will be set when parsing MeshFormat\n        self.version_major_ = None\n        self.version_minor_ = None\n        self.ascii_ = True\n        self.precision_ = 8  # t_size\n        self.number_of_node_entities_ = 0\n        self.number_of_nodes_ = 0\n        self.min_node_tag_ = 0\n        self.max_node_tag_ = 0\n        self.node_entities_ = {}\n        self.number_of_element_entities_ = 0\n        self.number_of_elements_ = 0\n        self.min_element_tag_ = 0\n        self.max_element_tag_ = 0\n        self.element_entities_ = {}\n\n    def set_name(self, name: str):\n        \"\"\"Set the name of the mesh.\"\"\"\n        self.name_ = name\n\n    def get_name(self) -&gt; str:\n        \"\"\"Get the name of the mesh.\"\"\"\n        return self.name_\n\n    def set_version(self, version: float):\n        \"\"\"Set the version of the Mesh object\"\"\"\n        self.version_ = version\n        # Parse major and minor version numbers\n        major = int(version)\n        minor = int(round((version - major) * 10))\n        self.version_major_ = major\n        self.version_minor_ = minor\n\n    def get_version(self) -&gt; Optional[float]:\n        \"\"\"Get the version of the Mesh object\"\"\"\n        return self.version_\n\n    def get_version_major(self) -&gt; Optional[int]:\n        \"\"\"Get the major version number.\"\"\"\n        return self.version_major_\n\n    def get_version_minor(self) -&gt; Optional[int]:\n        \"\"\"Get the minor version number.\"\"\"\n        return self.version_minor_\n\n    def set_ascii(self, is_ascii: bool):\n        \"\"\"Set a boolean flag whether this mesh is ASCII or binary\"\"\"\n        self.ascii_ = is_ascii\n\n    def get_ascii(self) -&gt; bool:\n        \"\"\"Get a boolean flag whether this mesh is ASCII of binary\"\"\"\n        return self.ascii_\n\n    def set_precision(self, precision: int):\n        \"\"\"Set the precision of the mesh (8)\"\"\"\n        self.precision_ = precision\n\n    def get_precision(self) -&gt; int:\n        \"\"\"Get the precision of the mesh\"\"\"\n        return self.precision_\n\n    def set_number_of_node_entities(self, number_of_node_entities: int):\n        \"\"\"Set number of node entities.\"\"\"\n        self.number_of_node_entities_ = number_of_node_entities\n\n    def get_number_of_node_entities(self) -&gt; int:\n        \"\"\"Get number of node entities.\"\"\"\n        return self.number_of_node_entities_\n\n    def set_number_of_nodes(self, number_of_nodes: int):\n        \"\"\"Set number of nodes.\"\"\"\n        self.number_of_nodes_ = number_of_nodes\n\n    def get_number_of_nodes(self) -&gt; int:\n        \"\"\"Get number of nodes.\"\"\"\n        return self.number_of_nodes_\n\n    def set_min_node_tag(self, min_node_tag: int):\n        \"\"\"Set node minimum tag.\"\"\"\n        self.min_node_tag_ = min_node_tag\n\n    def get_min_node_tag(self) -&gt; int:\n        \"\"\"Get node minimum tag.\"\"\"\n        return self.min_node_tag_\n\n    def set_max_node_tag(self, max_node_tag: int):\n        \"\"\"Set node maximum tag.\"\"\"\n        self.max_node_tag_ = max_node_tag\n\n    def get_max_node_tag(self) -&gt; int:\n        \"\"\"Get node maximum tag.\"\"\"\n        return self.max_node_tag_\n\n    def has_node_entity(self, dim: int, tag: int) -&gt; bool:\n        \"\"\"Test does mesh have node entity of dimension `dim` and tag `tag`.\"\"\"\n        return (dim, tag) in self.node_entities_\n\n    def add_node_entity(self, node_entity: NodeEntity):\n        \"\"\"Add node entity to mesh.\"\"\"\n        dim = node_entity.get_dimension()\n        tag = node_entity.get_tag()\n        self.node_entities_[(dim, tag)] = node_entity\n\n    def get_node_entity(self, dim: int, tag: int):\n        \"\"\"Get node entity based on dimension and tag.\"\"\"\n        return self.node_entities_[(dim, tag)]\n\n    def get_node_entities(self) -&gt; List[NodeEntity]:\n        \"\"\"Get all node entities of mesh.\"\"\"\n        return self.node_entities_.values()\n\n    def set_number_of_element_entities(self, number_of_element_entities: int):\n        \"\"\"Set number of element entities.\"\"\"\n        self.number_of_element_entities_ = number_of_element_entities\n\n    def get_number_of_element_entities(self) -&gt; int:\n        \"\"\"Get number of element entities.\"\"\"\n        return self.number_of_element_entities_\n\n    def set_number_of_elements(self, number_of_elements: int):\n        \"\"\"Set number of elements.\"\"\"\n        self.number_of_elements_ = number_of_elements\n\n    def get_number_of_elements(self) -&gt; int:\n        \"\"\"Get number of elements.\"\"\"\n        return self.number_of_elements_\n\n    def set_min_element_tag(self, min_element_tag: int):\n        \"\"\"Set element minimum tag.\"\"\"\n        self.min_element_tag_ = min_element_tag\n\n    def get_min_element_tag(self) -&gt; int:\n        \"\"\"Get element minimum tag.\"\"\"\n        return self.min_element_tag_\n\n    def set_max_element_tag(self, max_element_tag: int):\n        \"\"\"Set element maximum tag.\"\"\"\n        self.max_element_tag_ = max_element_tag\n\n    def get_max_element_tag(self) -&gt; int:\n        \"\"\"Get element maximum tag.\"\"\"\n        return self.max_element_tag_\n\n    def has_element_entity(self, dim: int, tag: int) -&gt; bool:\n        \"\"\"Test does mesh have element entity with `(dim, tag)`.\"\"\"\n        return (dim, tag) in self.element_entities_\n\n    def add_element_entity(self, element_entity: ElementEntity):\n        \"\"\"Add element entity to mesh.\"\"\"\n        dim = element_entity.get_dimension()\n        tag = element_entity.get_tag()\n        self.element_entities_[(dim, tag)] = element_entity\n\n    def get_element_entity(self, dim: int, tag: int) -&gt; ElementEntity:\n        \"\"\"Get element entity based on dimension `dim` and tag `tag`.\"\"\"\n        return self.element_entities_[(dim, tag)]\n\n    def get_element_entities(self) -&gt; List[ElementEntity]:\n        \"\"\"Get all element entities as dictionary.\"\"\"\n        return self.element_entities_.values()\n\n    def __str__(self):\n        io = StringIO()\n        io.write(\"Mesh name: %s\\n\" % self.get_name())\n        io.write(\"Mesh version: %s\\n\" % self.get_version())\n        io.write(\"Number of nodes: %s\\n\" % self.get_number_of_nodes())\n        io.write(\"Minimum node tag: %s\\n\" % self.get_min_node_tag())\n        io.write(\"Maximum node tag: %s\\n\" % self.get_max_node_tag())\n        nnent = self.get_number_of_node_entities()\n        io.write(\"Number of node entities: %s\\n\" % nnent)\n        io.write(\"Number of elements: %s\\n\" % self.get_number_of_elements())\n        io.write(\"Minimum element tag: %s\\n\" % self.get_min_element_tag())\n        io.write(\"Maximum element tag: %s\\n\" % self.get_max_element_tag())\n        neent = self.get_number_of_element_entities()\n        io.write(\"Number of element entities: %s\" % neent)\n        return io.getvalue()\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.add_element_entity","title":"<code>add_element_entity(element_entity)</code>","text":"<p>Add element entity to mesh.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def add_element_entity(self, element_entity: ElementEntity):\n    \"\"\"Add element entity to mesh.\"\"\"\n    dim = element_entity.get_dimension()\n    tag = element_entity.get_tag()\n    self.element_entities_[(dim, tag)] = element_entity\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.add_node_entity","title":"<code>add_node_entity(node_entity)</code>","text":"<p>Add node entity to mesh.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def add_node_entity(self, node_entity: NodeEntity):\n    \"\"\"Add node entity to mesh.\"\"\"\n    dim = node_entity.get_dimension()\n    tag = node_entity.get_tag()\n    self.node_entities_[(dim, tag)] = node_entity\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_ascii","title":"<code>get_ascii()</code>","text":"<p>Get a boolean flag whether this mesh is ASCII of binary</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_ascii(self) -&gt; bool:\n    \"\"\"Get a boolean flag whether this mesh is ASCII of binary\"\"\"\n    return self.ascii_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_element_entities","title":"<code>get_element_entities()</code>","text":"<p>Get all element entities as dictionary.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_element_entities(self) -&gt; List[ElementEntity]:\n    \"\"\"Get all element entities as dictionary.\"\"\"\n    return self.element_entities_.values()\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_element_entity","title":"<code>get_element_entity(dim, tag)</code>","text":"<p>Get element entity based on dimension <code>dim</code> and tag <code>tag</code>.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_element_entity(self, dim: int, tag: int) -&gt; ElementEntity:\n    \"\"\"Get element entity based on dimension `dim` and tag `tag`.\"\"\"\n    return self.element_entities_[(dim, tag)]\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_max_element_tag","title":"<code>get_max_element_tag()</code>","text":"<p>Get element maximum tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_max_element_tag(self) -&gt; int:\n    \"\"\"Get element maximum tag.\"\"\"\n    return self.max_element_tag_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_max_node_tag","title":"<code>get_max_node_tag()</code>","text":"<p>Get node maximum tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_max_node_tag(self) -&gt; int:\n    \"\"\"Get node maximum tag.\"\"\"\n    return self.max_node_tag_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_min_element_tag","title":"<code>get_min_element_tag()</code>","text":"<p>Get element minimum tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_min_element_tag(self) -&gt; int:\n    \"\"\"Get element minimum tag.\"\"\"\n    return self.min_element_tag_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_min_node_tag","title":"<code>get_min_node_tag()</code>","text":"<p>Get node minimum tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_min_node_tag(self) -&gt; int:\n    \"\"\"Get node minimum tag.\"\"\"\n    return self.min_node_tag_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_name","title":"<code>get_name()</code>","text":"<p>Get the name of the mesh.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"Get the name of the mesh.\"\"\"\n    return self.name_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_node_entities","title":"<code>get_node_entities()</code>","text":"<p>Get all node entities of mesh.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_node_entities(self) -&gt; List[NodeEntity]:\n    \"\"\"Get all node entities of mesh.\"\"\"\n    return self.node_entities_.values()\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_node_entity","title":"<code>get_node_entity(dim, tag)</code>","text":"<p>Get node entity based on dimension and tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_node_entity(self, dim: int, tag: int):\n    \"\"\"Get node entity based on dimension and tag.\"\"\"\n    return self.node_entities_[(dim, tag)]\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_number_of_element_entities","title":"<code>get_number_of_element_entities()</code>","text":"<p>Get number of element entities.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_number_of_element_entities(self) -&gt; int:\n    \"\"\"Get number of element entities.\"\"\"\n    return self.number_of_element_entities_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_number_of_elements","title":"<code>get_number_of_elements()</code>","text":"<p>Get number of elements.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_number_of_elements(self) -&gt; int:\n    \"\"\"Get number of elements.\"\"\"\n    return self.number_of_elements_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_number_of_node_entities","title":"<code>get_number_of_node_entities()</code>","text":"<p>Get number of node entities.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_number_of_node_entities(self) -&gt; int:\n    \"\"\"Get number of node entities.\"\"\"\n    return self.number_of_node_entities_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_number_of_nodes","title":"<code>get_number_of_nodes()</code>","text":"<p>Get number of nodes.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_number_of_nodes(self) -&gt; int:\n    \"\"\"Get number of nodes.\"\"\"\n    return self.number_of_nodes_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_precision","title":"<code>get_precision()</code>","text":"<p>Get the precision of the mesh</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_precision(self) -&gt; int:\n    \"\"\"Get the precision of the mesh\"\"\"\n    return self.precision_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_version","title":"<code>get_version()</code>","text":"<p>Get the version of the Mesh object</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_version(self) -&gt; Optional[float]:\n    \"\"\"Get the version of the Mesh object\"\"\"\n    return self.version_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_version_major","title":"<code>get_version_major()</code>","text":"<p>Get the major version number.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_version_major(self) -&gt; Optional[int]:\n    \"\"\"Get the major version number.\"\"\"\n    return self.version_major_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.get_version_minor","title":"<code>get_version_minor()</code>","text":"<p>Get the minor version number.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def get_version_minor(self) -&gt; Optional[int]:\n    \"\"\"Get the minor version number.\"\"\"\n    return self.version_minor_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.has_element_entity","title":"<code>has_element_entity(dim, tag)</code>","text":"<p>Test does mesh have element entity with <code>(dim, tag)</code>.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def has_element_entity(self, dim: int, tag: int) -&gt; bool:\n    \"\"\"Test does mesh have element entity with `(dim, tag)`.\"\"\"\n    return (dim, tag) in self.element_entities_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.has_node_entity","title":"<code>has_node_entity(dim, tag)</code>","text":"<p>Test does mesh have node entity of dimension <code>dim</code> and tag <code>tag</code>.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def has_node_entity(self, dim: int, tag: int) -&gt; bool:\n    \"\"\"Test does mesh have node entity of dimension `dim` and tag `tag`.\"\"\"\n    return (dim, tag) in self.node_entities_\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_ascii","title":"<code>set_ascii(is_ascii)</code>","text":"<p>Set a boolean flag whether this mesh is ASCII or binary</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_ascii(self, is_ascii: bool):\n    \"\"\"Set a boolean flag whether this mesh is ASCII or binary\"\"\"\n    self.ascii_ = is_ascii\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_max_element_tag","title":"<code>set_max_element_tag(max_element_tag)</code>","text":"<p>Set element maximum tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_max_element_tag(self, max_element_tag: int):\n    \"\"\"Set element maximum tag.\"\"\"\n    self.max_element_tag_ = max_element_tag\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_max_node_tag","title":"<code>set_max_node_tag(max_node_tag)</code>","text":"<p>Set node maximum tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_max_node_tag(self, max_node_tag: int):\n    \"\"\"Set node maximum tag.\"\"\"\n    self.max_node_tag_ = max_node_tag\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_min_element_tag","title":"<code>set_min_element_tag(min_element_tag)</code>","text":"<p>Set element minimum tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_min_element_tag(self, min_element_tag: int):\n    \"\"\"Set element minimum tag.\"\"\"\n    self.min_element_tag_ = min_element_tag\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_min_node_tag","title":"<code>set_min_node_tag(min_node_tag)</code>","text":"<p>Set node minimum tag.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_min_node_tag(self, min_node_tag: int):\n    \"\"\"Set node minimum tag.\"\"\"\n    self.min_node_tag_ = min_node_tag\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_name","title":"<code>set_name(name)</code>","text":"<p>Set the name of the mesh.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_name(self, name: str):\n    \"\"\"Set the name of the mesh.\"\"\"\n    self.name_ = name\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_number_of_element_entities","title":"<code>set_number_of_element_entities(number_of_element_entities)</code>","text":"<p>Set number of element entities.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_number_of_element_entities(self, number_of_element_entities: int):\n    \"\"\"Set number of element entities.\"\"\"\n    self.number_of_element_entities_ = number_of_element_entities\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_number_of_elements","title":"<code>set_number_of_elements(number_of_elements)</code>","text":"<p>Set number of elements.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_number_of_elements(self, number_of_elements: int):\n    \"\"\"Set number of elements.\"\"\"\n    self.number_of_elements_ = number_of_elements\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_number_of_node_entities","title":"<code>set_number_of_node_entities(number_of_node_entities)</code>","text":"<p>Set number of node entities.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_number_of_node_entities(self, number_of_node_entities: int):\n    \"\"\"Set number of node entities.\"\"\"\n    self.number_of_node_entities_ = number_of_node_entities\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_number_of_nodes","title":"<code>set_number_of_nodes(number_of_nodes)</code>","text":"<p>Set number of nodes.</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_number_of_nodes(self, number_of_nodes: int):\n    \"\"\"Set number of nodes.\"\"\"\n    self.number_of_nodes_ = number_of_nodes\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_precision","title":"<code>set_precision(precision)</code>","text":"<p>Set the precision of the mesh (8)</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_precision(self, precision: int):\n    \"\"\"Set the precision of the mesh (8)\"\"\"\n    self.precision_ = precision\n</code></pre>"},{"location":"api/mesh/#gmshparser.mesh.Mesh.set_version","title":"<code>set_version(version)</code>","text":"<p>Set the version of the Mesh object</p> Source code in <code>gmshparser/mesh.py</code> <pre><code>def set_version(self, version: float):\n    \"\"\"Set the version of the Mesh object\"\"\"\n    self.version_ = version\n    # Parse major and minor version numbers\n    major = int(version)\n    minor = int(round((version - major) * 10))\n    self.version_major_ = major\n    self.version_minor_ = minor\n</code></pre>"},{"location":"api/mesh/#usage-examples","title":"Usage Examples","text":""},{"location":"api/mesh/#basic-information","title":"Basic Information","text":"<pre><code>mesh = gmshparser.parse(\"mesh.msh\")\n\n# Version info\nversion = mesh.get_version()\nis_ascii = mesh.is_ascii()\n\n# Counts\nnum_nodes = mesh.get_number_of_nodes()\nnum_elements = mesh.get_number_of_elements()\nnum_node_entities = mesh.get_number_of_node_entities()\nnum_element_entities = mesh.get_number_of_element_entities()\n\n# Tag ranges\nmin_node_tag = mesh.get_min_node_tag()\nmax_node_tag = mesh.get_max_node_tag()\nmin_element_tag = mesh.get_min_element_tag()\nmax_element_tag = mesh.get_max_element_tag()\n</code></pre>"},{"location":"api/mesh/#accessing-data","title":"Accessing Data","text":"<pre><code># Get all node entities\nnode_entities = mesh.get_node_entities()\n\n# Get all element entities\nelement_entities = mesh.get_element_entities()\n\n# Get mesh name (filename)\nname = mesh.get_name()\n</code></pre>"},{"location":"api/mesh/#related-classes","title":"Related Classes","text":"<ul> <li>Node - Individual node</li> <li>NodeEntity - Group of nodes</li> <li>Element - Individual element</li> <li>ElementEntity - Group of elements</li> </ul>"},{"location":"api/overview/","title":"API Reference","text":"<p>gmshparser provides a simple, clean API for parsing Gmsh mesh files.</p>"},{"location":"api/overview/#main-functions","title":"Main Functions","text":""},{"location":"api/overview/#parse","title":"parse()","text":"<p>Parse a Gmsh mesh file and return a Mesh object.</p> <pre><code>import gmshparser\n\nmesh = gmshparser.parse(\"mesh.msh\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>filename</code> (str): Path to the <code>.msh</code> file</li> </ul> <p>Returns:</p> <ul> <li><code>Mesh</code>: Parsed mesh object</li> </ul> <p>Raises:</p> <ul> <li><code>FileNotFoundError</code>: If file doesn't exist</li> <li><code>ValueError</code>: If file format is unsupported or invalid</li> </ul>"},{"location":"api/overview/#core-classes","title":"Core Classes","text":""},{"location":"api/overview/#mesh","title":"Mesh","text":"<p>The main mesh container class.</p> <p>For detailed API, see Mesh API.</p>"},{"location":"api/overview/#node-nodeentity","title":"Node &amp; NodeEntity","text":"<p>Classes for node data organization.</p>"},{"location":"api/overview/#element-elemententity","title":"Element &amp; ElementEntity","text":"<p>Classes for element data organization.</p>"},{"location":"api/overview/#parsers","title":"Parsers","text":"<p>Parser classes for different mesh sections.</p> <p>See Parsers API for details.</p>"},{"location":"api/overview/#helper-functions","title":"Helper Functions","text":"<p>Utility functions for common mesh operations.</p> <p>See Helpers API for details.</p>"},{"location":"api/overview/#quick-reference","title":"Quick Reference","text":"<pre><code>import gmshparser\n\n# Parse mesh\nmesh = gmshparser.parse(\"mesh.msh\")\n\n# Get mesh info\nmesh.get_version()\nmesh.get_number_of_nodes()\nmesh.get_number_of_elements()\n\n# Access nodes\nfor entity in mesh.get_node_entities():\n    for node in entity.get_nodes():\n        node.get_tag()\n        node.get_coordinates()\n\n# Access elements\nfor entity in mesh.get_element_entities():\n    for element in entity.get_elements():\n        element.get_tag()\n        element.get_connectivity()\n\n# Helper functions\nfrom gmshparser.helpers import get_triangles, get_quads, get_elements_2d\n\nX, Y, T = get_triangles(mesh)\nX, Y, Q = get_quads(mesh)\nX, Y, triangles, quads = get_elements_2d(mesh)\n</code></pre>"},{"location":"api/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Mesh API - Complete Mesh class reference</li> <li>Parsers API - Parser classes</li> <li>Helpers API - Utility functions</li> </ul>"},{"location":"api/parsers/","title":"Parsers API","text":""},{"location":"api/parsers/#abstractparser","title":"AbstractParser","text":"<p>Base class for all parsers.</p>"},{"location":"api/parsers/#gmshparser.abstract_parser.AbstractParser","title":"<code>gmshparser.abstract_parser.AbstractParser</code>","text":"<p>               Bases: <code>object</code></p> <p>AbstractParser is a superclass of all other parsers.</p> <p>All other parsers must inheric <code>AbstractParser</code> and implement their own static methods <code>parse</code> and <code>get_section_name</code>.</p> <p>The first argument of the <code>parse</code> is a mutable <code>mesh</code> object, which parser modifies in-place. The second argument is <code>io</code>, where parser reads the text file line by line using <code>readline()</code>. Parser must stop reading the file to the section end mark, e.g. <code>$EndNodes</code> in the case of parser which is responsible to parse nodes, starting from a section start mark <code>$Nodes</code>.</p> <p>Another must-to-implement static method is <code>get_section_name()</code>, which must return the name of the line where this parser should activate. For example, if the section name is <code>$Nodes</code>, then <code>get_section_name()</code> must return string <code>$Nodes</code>.</p> Source code in <code>gmshparser/abstract_parser.py</code> <pre><code>class AbstractParser(object):\n    \"\"\"AbstractParser is a superclass of all other parsers.\n\n    All other parsers must inheric ``AbstractParser`` and implement their own\n    static methods ``parse`` and ``get_section_name``.\n\n    The first argument of the ``parse`` is a mutable ``mesh`` object, which\n    parser modifies in-place. The second argument is ``io``, where parser reads\n    the text file line by line using `readline()`. Parser must stop reading the\n    file to the section end mark, e.g. ``$EndNodes`` in the case of parser\n    which is responsible to parse nodes, starting from a section start mark\n    ``$Nodes``.\n\n    Another must-to-implement static method is ``get_section_name()``, which\n    must return the name of the line where this parser should activate. For\n    example, if the section name is ``$Nodes``, then ``get_section_name()``\n    must return string ``$Nodes``.\n    \"\"\"\n\n    @staticmethod\n    def get_section_name():\n        raise NotImplementedError(\"Not implemented.\")\n\n    @staticmethod\n    def parse(mesh: Mesh, io: TextIO) -&gt; None:\n        raise NotImplementedError(\"Not implemented.\")\n</code></pre>"},{"location":"api/parsers/#meshformatparser","title":"MeshFormatParser","text":"<p>Parses <code>$MeshFormat</code> section.</p>"},{"location":"api/parsers/#nodesparser","title":"NodesParser","text":"<p>Parses <code>$Nodes</code> section (MSH 2.x and 4.x).</p>"},{"location":"api/parsers/#elementsparser","title":"ElementsParser","text":"<p>Parses <code>$Elements</code> section (MSH 2.x and 4.x).</p>"},{"location":"api/parsers/#v1-parsers","title":"V1 Parsers","text":""},{"location":"api/parsers/#nodesparserv1","title":"NodesParserV1","text":"<p>Parses <code>$NOD</code> section (MSH 1.0).</p>"},{"location":"api/parsers/#elementsparserv1","title":"ElementsParserV1","text":"<p>Parses <code>$ELM</code> section (MSH 1.0).</p>"},{"location":"api/parsers/#mainparser","title":"MainParser","text":"<p>Coordinates all parsers and handles version detection.</p>"},{"location":"api/parsers/#gmshparser.main_parser.MainParser","title":"<code>gmshparser.main_parser.MainParser</code>","text":"<p>               Bases: <code>AbstractParser</code></p> <p>The main parser class, using other parsers.</p> <p>This parser automatically detects the MSH format version and selects the appropriate parsers for that version.</p> Source code in <code>gmshparser/main_parser.py</code> <pre><code>class MainParser(AbstractParser):\n    \"\"\"The main parser class, using other parsers.\n\n    This parser automatically detects the MSH format version and selects\n    the appropriate parsers for that version.\n    \"\"\"\n\n    def __init__(self, parsers=None):\n        \"\"\"Initialize the main parser.\n\n        Parameters\n        ----------\n        parsers : list, optional\n            List of parser classes to use. If None, parsers will be selected\n            automatically based on the detected version.\n        \"\"\"\n        self.parsers = parsers\n        self.version_detected = False\n\n    def parse(self, mesh: Mesh, io: TextIO) -&gt; None:\n        \"\"\"Parse the mesh file.\n\n        The parser first reads the MeshFormat section to detect the version,\n        then selects the appropriate parsers for that version.\n\n        For MSH 1.0 files (which don't have $MeshFormat), version is detected\n        from the $NOD section name.\n\n        Parameters\n        ----------\n        mesh : Mesh\n            Mesh object to populate\n        io : TextIO\n            Input stream to read from\n\n        Raises\n        ------\n        ValueError\n            If the version is not supported or if parsing fails\n        \"\"\"\n        for line in io:\n            line = line.strip()\n\n            # Check for MSH 1.0 format (starts with $NOD instead of $MeshFormat)\n            if line == \"$NOD\" and not self.version_detected:\n                # Set version to 1.0\n                mesh.set_version(1.0)\n                self.version_detected = True\n\n                # Select MSH 1.0 parsers\n                if self.parsers is None:\n                    self.parsers = DEFAULT_PARSERS_V1\n\n                # Parse the $NOD section\n                try:\n                    NodesParserV1.parse(mesh, io)\n                except Exception:\n                    print(\"Unable to parse section %s from mesh!\" % line)\n                    raise\n                continue\n\n            # Handle MeshFormat for MSH 2.x and 4.x\n            if line == \"$MeshFormat\" and not self.version_detected:\n                try:\n                    MeshFormatParser.parse(mesh, io)\n                    self.version_detected = True\n\n                    # Select parsers based on detected version if not explicitly set\n                    if self.parsers is None:\n                        self.parsers = self._get_parsers_for_version(mesh)\n\n                except Exception:\n                    print(\"Unable to parse section %s from mesh!\" % line)\n                    raise\n                continue\n\n            # Then, handle other sections with version-specific parsers\n            if self.parsers:\n                for parser in self.parsers:\n                    if parser.get_section_name() == line:\n                        try:\n                            parser.parse(mesh, io)\n                        except Exception:\n                            print(\"Unable to parse section %s from mesh!\" % line)\n                            raise\n                        break\n\n    def _get_parsers_for_version(self, mesh: Mesh) -&gt; List[Type[AbstractParser]]:\n        \"\"\"Get the appropriate parsers for the detected mesh version.\n\n        Parameters\n        ----------\n        mesh : Mesh\n            Mesh with version information\n\n        Returns\n        -------\n        List[Type[AbstractParser]]\n            List of parser classes to use\n\n        Raises\n        ------\n        ValueError\n            If version information is not available\n        \"\"\"\n        version = mesh.get_version()\n        if version is None:\n            raise ValueError(\"Cannot determine parsers: version not detected\")\n\n        major = mesh.get_version_major()\n\n        if major == 1:\n            return DEFAULT_PARSERS_V1\n        elif major == 2:\n            return DEFAULT_PARSERS_V2\n        elif major == 4:\n            return DEFAULT_PARSERS_V4\n        else:\n            raise ValueError(f\"Unsupported MSH format version: {version}\")\n</code></pre>"},{"location":"api/parsers/#gmshparser.main_parser.MainParser.__init__","title":"<code>__init__(parsers=None)</code>","text":"<p>Initialize the main parser.</p>"},{"location":"api/parsers/#gmshparser.main_parser.MainParser.__init__--parameters","title":"Parameters","text":"<p>parsers : list, optional     List of parser classes to use. If None, parsers will be selected     automatically based on the detected version.</p> Source code in <code>gmshparser/main_parser.py</code> <pre><code>def __init__(self, parsers=None):\n    \"\"\"Initialize the main parser.\n\n    Parameters\n    ----------\n    parsers : list, optional\n        List of parser classes to use. If None, parsers will be selected\n        automatically based on the detected version.\n    \"\"\"\n    self.parsers = parsers\n    self.version_detected = False\n</code></pre>"},{"location":"api/parsers/#gmshparser.main_parser.MainParser.parse","title":"<code>parse(mesh, io)</code>","text":"<p>Parse the mesh file.</p> <p>The parser first reads the MeshFormat section to detect the version, then selects the appropriate parsers for that version.</p> <p>For MSH 1.0 files (which don't have $MeshFormat), version is detected from the $NOD section name.</p>"},{"location":"api/parsers/#gmshparser.main_parser.MainParser.parse--parameters","title":"Parameters","text":"<p>mesh : Mesh     Mesh object to populate io : TextIO     Input stream to read from</p>"},{"location":"api/parsers/#gmshparser.main_parser.MainParser.parse--raises","title":"Raises","text":"<p>ValueError     If the version is not supported or if parsing fails</p> Source code in <code>gmshparser/main_parser.py</code> <pre><code>def parse(self, mesh: Mesh, io: TextIO) -&gt; None:\n    \"\"\"Parse the mesh file.\n\n    The parser first reads the MeshFormat section to detect the version,\n    then selects the appropriate parsers for that version.\n\n    For MSH 1.0 files (which don't have $MeshFormat), version is detected\n    from the $NOD section name.\n\n    Parameters\n    ----------\n    mesh : Mesh\n        Mesh object to populate\n    io : TextIO\n        Input stream to read from\n\n    Raises\n    ------\n    ValueError\n        If the version is not supported or if parsing fails\n    \"\"\"\n    for line in io:\n        line = line.strip()\n\n        # Check for MSH 1.0 format (starts with $NOD instead of $MeshFormat)\n        if line == \"$NOD\" and not self.version_detected:\n            # Set version to 1.0\n            mesh.set_version(1.0)\n            self.version_detected = True\n\n            # Select MSH 1.0 parsers\n            if self.parsers is None:\n                self.parsers = DEFAULT_PARSERS_V1\n\n            # Parse the $NOD section\n            try:\n                NodesParserV1.parse(mesh, io)\n            except Exception:\n                print(\"Unable to parse section %s from mesh!\" % line)\n                raise\n            continue\n\n        # Handle MeshFormat for MSH 2.x and 4.x\n        if line == \"$MeshFormat\" and not self.version_detected:\n            try:\n                MeshFormatParser.parse(mesh, io)\n                self.version_detected = True\n\n                # Select parsers based on detected version if not explicitly set\n                if self.parsers is None:\n                    self.parsers = self._get_parsers_for_version(mesh)\n\n            except Exception:\n                print(\"Unable to parse section %s from mesh!\" % line)\n                raise\n            continue\n\n        # Then, handle other sections with version-specific parsers\n        if self.parsers:\n            for parser in self.parsers:\n                if parser.get_section_name() == line:\n                    try:\n                        parser.parse(mesh, io)\n                    except Exception:\n                        print(\"Unable to parse section %s from mesh!\" % line)\n                        raise\n                    break\n</code></pre>"},{"location":"api/parsers/#see-also","title":"See Also","text":"<ul> <li>Writing Custom Parsers</li> <li>Architecture</li> </ul>"},{"location":"developer-guide/architecture/","title":"Architecture","text":"<p>This document explains gmshparser's internal architecture and design decisions.</p>"},{"location":"developer-guide/architecture/#design-philosophy","title":"Design Philosophy","text":"<p>gmshparser follows these principles:</p> <ol> <li>Single responsibility: Parse Gmsh mesh files, nothing more</li> <li>Zero dependencies: Pure Python, no external dependencies</li> <li>Extensibility: Easy to add new parsers for new sections</li> <li>Version agnostic: Same API regardless of MSH version</li> <li>Test-driven: 100% test coverage goal</li> </ol>"},{"location":"developer-guide/architecture/#system-overview","title":"System Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  User Code  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 gmshparser.parse(\"mesh.msh\")\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MainParser  \u2502 \u25c4\u2500\u2500\u2500 Coordinates parsing\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 Detects version\n       \u251c\u2500\u25ba MSH 1.0 \u2192 V1 Parsers\n       \u251c\u2500\u25ba MSH 2.x \u2192 V2 Parsers\n       \u2514\u2500\u25ba MSH 4.x \u2192 V4 Parsers\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Mesh     \u2502 \u25c4\u2500\u2500\u2500 Data model\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"developer-guide/architecture/#core-components","title":"Core Components","text":""},{"location":"developer-guide/architecture/#1-mesh-data-model","title":"1. Mesh Data Model","text":"<p>The <code>Mesh</code> class is the central data structure:</p> <pre><code>class Mesh:\n    - name: str\n    - version: float\n    - node_entities: List[NodeEntity]\n    - element_entities: List[ElementEntity]\n    # ... accessors and methods\n</code></pre> <p>Node hierarchy:</p> <pre><code>Mesh\n  \u2514\u2500\u25ba NodeEntity (dimension, tag, parametric)\n        \u2514\u2500\u25ba Node (tag, coordinates)\n</code></pre> <p>Element hierarchy:</p> <pre><code>Mesh\n  \u2514\u2500\u25ba ElementEntity (dimension, tag, element_type)\n        \u2514\u2500\u25ba Element (tag, connectivity)\n</code></pre>"},{"location":"developer-guide/architecture/#2-parser-system","title":"2. Parser System","text":""},{"location":"developer-guide/architecture/#abstract-parser","title":"Abstract Parser","text":"<p>All parsers inherit from <code>AbstractParser</code>:</p> <pre><code>class AbstractParser:\n    @staticmethod\n    def get_section_name() -&gt; str:\n        \"\"\"Return section name like '$MeshFormat'\"\"\"\n        pass\n\n    @staticmethod\n    def parse(mesh: Mesh, io: TextIO) -&gt; None:\n        \"\"\"Parse section and populate mesh\"\"\"\n        pass\n</code></pre>"},{"location":"developer-guide/architecture/#parser-registry","title":"Parser Registry","text":"<p>The <code>MainParser</code> maintains a registry of parsers:</p> <pre><code>DEFAULT_PARSERS = [\n    MeshFormatParser,\n    NodesParser,\n    ElementsParser,\n]\n</code></pre> <p>When a section is encountered (e.g., <code>$Nodes</code>), <code>MainParser</code> finds the appropriate parser and delegates.</p>"},{"location":"developer-guide/architecture/#3-version-manager","title":"3. Version Manager","text":"<p>The <code>VersionManager</code> handles version detection and validation:</p> <pre><code>class MSHVersion(Enum):\n    V1_0 = 1.0\n    V2_0 = 2.0\n    V2_1 = 2.1\n    V2_2 = 2.2\n    V4_0 = 4.0\n    V4_1 = 4.1\n</code></pre> <p>Functions:</p> <ul> <li><code>parse_version(version_str: str) -&gt; float</code></li> <li><code>is_supported(version: float) -&gt; bool</code></li> <li><code>validate_version(version: float) -&gt; None</code></li> <li><code>is_version_1(version: float) -&gt; bool</code></li> <li><code>is_version_2(version: float) -&gt; bool</code></li> <li><code>is_version_4(version: float) -&gt; bool</code></li> </ul>"},{"location":"developer-guide/architecture/#parsing-flow","title":"Parsing Flow","text":""},{"location":"developer-guide/architecture/#high-level-flow","title":"High-Level Flow","text":"<pre><code>parse(\"mesh.msh\")\n    \u2502\n    \u251c\u2500\u25ba Open file\n    \u2502\n    \u251c\u2500\u25ba Create Mesh object\n    \u2502\n    \u251c\u2500\u25ba MainParser.parse(mesh, file)\n    \u2502     \u2502\n    \u2502     \u251c\u2500\u25ba Detect version (first line)\n    \u2502     \u2502\n    \u2502     \u251c\u2500\u25ba Select parsers based on version\n    \u2502     \u2502\n    \u2502     \u2514\u2500\u25ba For each section:\n    \u2502           \u2514\u2500\u25ba Find matching parser\n    \u2502               \u2514\u2500\u25ba Parser.parse(mesh, file)\n    \u2502\n    \u2514\u2500\u25ba Return populated Mesh\n</code></pre>"},{"location":"developer-guide/architecture/#version-detection","title":"Version Detection","text":"<pre><code># Read first line\nline = io.readline().strip()\n\nif line == \"$MeshFormat\":\n    # MSH 2.x or 4.x\n    version_line = io.readline().strip()\n    version = float(version_line.split()[0])\nelif line == \"$NOD\":\n    # MSH 1.0 (legacy)\n    version = 1.0\nelse:\n    raise ValueError(\"Unknown format\")\n</code></pre>"},{"location":"developer-guide/architecture/#version-specific-routing","title":"Version-Specific Routing","text":"<p>MSH 1.0:</p> <pre><code>parsers = [\n    NodesParserV1,      # Parses $NOD section\n    ElementsParserV1,   # Parses $ELM section\n]\n</code></pre> <p>MSH 2.x:</p> <pre><code>parsers = [\n    MeshFormatParser,   # Parses $MeshFormat\n    NodesParser,        # Parses $Nodes (V2 format)\n    ElementsParser,     # Parses $Elements (V2 format)\n]\n</code></pre> <p>MSH 4.x:</p> <pre><code>parsers = [\n    MeshFormatParser,   # Parses $MeshFormat\n    NodesParser,        # Parses $Nodes (V4 format)\n    ElementsParser,     # Parses $Elements (V4 format)\n]\n</code></pre> <p>Note: MSH 4.x uses the same parser classes as MSH 2.x, but they handle the format differences internally.</p>"},{"location":"developer-guide/architecture/#module-structure","title":"Module Structure","text":"<pre><code>gmshparser/\n\u251c\u2500\u2500 __init__.py           # Public API: parse()\n\u251c\u2500\u2500 mesh.py               # Mesh data model\n\u251c\u2500\u2500 node.py               # Node class\n\u251c\u2500\u2500 node_entity.py        # NodeEntity class\n\u251c\u2500\u2500 element.py            # Element class\n\u251c\u2500\u2500 element_entity.py     # ElementEntity class\n\u251c\u2500\u2500 abstract_parser.py    # Parser base class\n\u251c\u2500\u2500 main_parser.py        # Main parser coordinator\n\u251c\u2500\u2500 version_manager.py    # Version detection/validation\n\u251c\u2500\u2500 mesh_format_parser.py # $MeshFormat parser\n\u251c\u2500\u2500 nodes_parser.py       # $Nodes parser (V2/V4)\n\u251c\u2500\u2500 nodes_parser_v1.py    # $NOD parser (V1)\n\u251c\u2500\u2500 nodes_parser_v2.py    # Specialized V2 $Nodes parser\n\u251c\u2500\u2500 elements_parser.py    # $Elements parser (V2/V4)\n\u251c\u2500\u2500 elements_parser_v1.py # $ELM parser (V1)\n\u251c\u2500\u2500 elements_parser_v2.py # Specialized V2 $Elements parser\n\u251c\u2500\u2500 helpers.py            # Utility functions\n\u2514\u2500\u2500 cli.py                # Command-line interface\n</code></pre>"},{"location":"developer-guide/architecture/#data-flow-example","title":"Data Flow Example","text":""},{"location":"developer-guide/architecture/#parsing-msh-41-file","title":"Parsing MSH 4.1 File","text":"<pre><code>File: mesh.msh (MSH 4.1)\n    \u2502\n    \u25bc\n$MeshFormat\n4.1 0 8\n$EndMeshFormat\n    \u2502\n    \u251c\u2500\u25ba MeshFormatParser\n    \u2502     \u2514\u2500\u25ba mesh.set_version(4.1)\n    \u2502\n$Nodes\n1 6 1 6\n...\n$EndNodes\n    \u2502\n    \u251c\u2500\u25ba NodesParser\n    \u2502     \u2514\u2500\u25ba Parse entity blocks\n    \u2502           \u2514\u2500\u25ba Create NodeEntity\n    \u2502                 \u2514\u2500\u25ba Add Node objects\n    \u2502\n$Elements\n1 2 1 2\n...\n$EndElements\n    \u2502\n    \u2514\u2500\u25ba ElementsParser\n          \u2514\u2500\u25ba Parse entity blocks\n                \u2514\u2500\u25ba Create ElementEntity\n                      \u2514\u2500\u25ba Add Element objects\n</code></pre>"},{"location":"developer-guide/architecture/#extension-points","title":"Extension Points","text":""},{"location":"developer-guide/architecture/#adding-a-new-parser","title":"Adding a New Parser","text":"<p>To parse a new section (e.g., <code>$PhysicalNames</code>):</p> <ol> <li>Create parser class:</li> </ol> <pre><code>class PhysicalNamesParser(AbstractParser):\n    @staticmethod\n    def get_section_name():\n        return \"$PhysicalNames\"\n\n    @staticmethod\n    def parse(mesh: Mesh, io: TextIO) -&gt; None:\n        num_names = int(io.readline().strip())\n        for _ in range(num_names):\n            line = io.readline().strip().split()\n            dimension = int(line[0])\n            tag = int(line[1])\n            name = \" \".join(line[2:]).strip('\"')\n            # Store in mesh...\n</code></pre> <ol> <li>Register parser:</li> </ol> <pre><code># In main_parser.py\nDEFAULT_PARSERS = [\n    MeshFormatParser,\n    PhysicalNamesParser,  # \u2190 Add here\n    NodesParser,\n    ElementsParser,\n]\n</code></pre> <ol> <li>Test:</li> </ol> <pre><code>def test_physical_names_parser():\n    mesh = gmshparser.parse(\"mesh_with_physical_names.msh\")\n    # Verify physical names were parsed...\n</code></pre>"},{"location":"developer-guide/architecture/#adding-helper-functions","title":"Adding Helper Functions","text":"<p>Helper functions for common operations go in <code>helpers.py</code>:</p> <pre><code>def get_quads(mesh: Mesh) -&gt; Tuple[List[float], List[float], List[List[int]]]:\n    \"\"\"Extract quadrilateral elements from mesh.\"\"\"\n    # Implementation...\n</code></pre>"},{"location":"developer-guide/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"developer-guide/architecture/#memory","title":"Memory","text":"<ul> <li>Lazy loading: Not implemented (all data loaded at once)</li> <li>Memory usage: Proportional to mesh size</li> <li>Large meshes: May require significant RAM</li> </ul>"},{"location":"developer-guide/architecture/#speed","title":"Speed","text":"<ul> <li>File I/O: Uses standard Python <code>open()</code></li> <li>Parsing: Simple string operations</li> <li>Bottleneck: Usually file I/O, not parsing logic</li> </ul>"},{"location":"developer-guide/architecture/#optimization-opportunities","title":"Optimization Opportunities","text":"<ol> <li>Binary format support: Faster parsing</li> <li>Streaming: Parse nodes/elements on-demand</li> <li>Cython: Compile performance-critical sections</li> <li>NumPy: Use arrays for coordinate storage</li> </ol>"},{"location":"developer-guide/architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"developer-guide/architecture/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 test_mesh.py              # Mesh class\n\u251c\u2500\u2500 test_node.py              # Node class\n\u251c\u2500\u2500 test_element.py           # Element class\n\u251c\u2500\u2500 test_mesh_format_parser.py # Format parser\n\u251c\u2500\u2500 test_nodes_parser.py       # Nodes parser\n\u251c\u2500\u2500 test_elements_parser.py    # Elements parser\n\u251c\u2500\u2500 test_multi_version.py      # Version support\n\u251c\u2500\u2500 test_version_manager.py    # Version detection\n\u251c\u2500\u2500 test_helpers.py            # Helper functions\n\u2514\u2500\u2500 test_cli.py                # CLI\n</code></pre>"},{"location":"developer-guide/architecture/#test-data","title":"Test Data","text":"<p>Located in <code>testdata/</code>:</p> <ul> <li>Simple meshes for unit tests</li> <li>Complex meshes from real-world use</li> <li>Version-specific meshes (v1.0, v2.0, v4.1, etc.)</li> </ul>"},{"location":"developer-guide/architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"developer-guide/architecture/#why-no-dependencies","title":"Why No Dependencies?","text":"<p>Pros:</p> <ul> <li>Easy installation</li> <li>No dependency conflicts</li> <li>Portable and lightweight</li> <li>Works in restricted environments</li> </ul> <p>Cons:</p> <ul> <li>Can't use NumPy for faster array operations</li> <li>No XML parsing (if needed for newer Gmsh features)</li> </ul> <p>Decision: Prioritize simplicity and portability.</p>"},{"location":"developer-guide/architecture/#why-read-only","title":"Why Read-Only?","text":"<p>Rationale:</p> <ul> <li>Writing MSH files is complex and error-prone</li> <li>Gmsh itself is better for mesh generation</li> <li>Parser's job is to read, not write</li> <li>Keeps codebase focused</li> </ul>"},{"location":"developer-guide/architecture/#why-not-support-binary-format","title":"Why Not Support Binary Format?","text":"<p>Reasons:</p> <ul> <li>Binary format is version-specific</li> <li>Requires careful endianness handling</li> <li>ASCII is \"good enough\" for most use cases</li> <li>Can be added later if needed</li> </ul>"},{"location":"developer-guide/architecture/#future-architecture-considerations","title":"Future Architecture Considerations","text":""},{"location":"developer-guide/architecture/#potential-improvements","title":"Potential Improvements","text":"<ol> <li>Pluggable parsers: Allow users to register custom parsers</li> <li>Streaming API: For very large meshes</li> <li>Binary support: Faster parsing</li> <li>Writer: Mesh export functionality</li> <li>NumPy integration: Optional NumPy arrays for coordinates</li> </ol>"},{"location":"developer-guide/architecture/#backward-compatibility","title":"Backward Compatibility","text":"<p>All public API changes will:</p> <ul> <li>Follow semantic versioning</li> <li>Maintain backward compatibility for minor versions</li> <li>Provide deprecation warnings before removal</li> </ul>"},{"location":"developer-guide/architecture/#related-documentation","title":"Related Documentation","text":"<ul> <li>Writing Parsers</li> <li>Testing Guide</li> <li>API Reference</li> </ul>"},{"location":"developer-guide/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to gmshparser! This guide will help you get started.</p>"},{"location":"developer-guide/contributing/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"developer-guide/contributing/#report-bugs","title":"Report Bugs","text":"<p>Found a bug? Please open an issue with:</p> <ul> <li>A clear description of the problem</li> <li>Steps to reproduce the issue</li> <li>Expected vs. actual behavior</li> <li>Your Python version and operating system</li> <li>Sample mesh file (if applicable)</li> </ul>"},{"location":"developer-guide/contributing/#suggest-features","title":"Suggest Features","text":"<p>Have an idea for improvement? Open an issue describing:</p> <ul> <li>The feature you'd like to see</li> <li>Why it would be useful</li> <li>Potential implementation approach</li> </ul>"},{"location":"developer-guide/contributing/#improve-documentation","title":"Improve Documentation","text":"<p>Documentation improvements are always welcome:</p> <ul> <li>Fix typos or clarify explanations</li> <li>Add examples</li> <li>Improve API documentation</li> <li>Translate documentation</li> </ul>"},{"location":"developer-guide/contributing/#submit-code","title":"Submit Code","text":""},{"location":"developer-guide/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository</li> </ol> <pre><code># Click \"Fork\" on GitHub, then clone your fork\ngit clone https://github.com/YOUR_USERNAME/gmshparser.git\ncd gmshparser\n</code></pre> <ol> <li>Set up development environment</li> </ol> <pre><code># Install Poetry (if not already installed)\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Install dependencies\npoetry install\n\n# Activate virtual environment\npoetry shell\n</code></pre> <ol> <li>Create a branch</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre>"},{"location":"developer-guide/contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li>Make your changes</li> </ol> <p>Write code following the project style (see below).</p> <ol> <li>Run tests</li> </ol> <pre><code>pytest\n</code></pre> <p>Ensure all tests pass and coverage remains high:</p> <pre><code>pytest --cov=gmshparser --cov-report=term-missing\n</code></pre> <ol> <li>Format code</li> </ol> <pre><code>black .\n</code></pre> <ol> <li>Check code quality</li> </ol> <pre><code>flake8 gmshparser tests\n</code></pre> <ol> <li>Commit your changes</li> </ol> <p>Write clear, descriptive commit messages:</p> <pre><code>git add .\ngit commit -m \"Add support for XYZ feature\n\n- Implemented XYZ parser\n- Added tests for XYZ\n- Updated documentation\"\n</code></pre> <ol> <li>Push to your fork</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Create a pull request</li> </ol> <p>Go to GitHub and create a pull request from your fork to the main repository.</p>"},{"location":"developer-guide/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"developer-guide/contributing/#style-guide","title":"Style Guide","text":"<ul> <li>Follow PEP 8</li> <li>Use <code>black</code> for formatting (line length: 88)</li> <li>Use <code>flake8</code> for linting</li> <li>Write docstrings for all public functions/classes</li> </ul>"},{"location":"developer-guide/contributing/#example","title":"Example","text":"<pre><code>def parse_section(mesh: Mesh, io: TextIO) -&gt; None:\n    \"\"\"Parse a section from the mesh file.\n\n    Args:\n        mesh: The Mesh object to populate\n        io: File handle to read from\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If section format is invalid\n    \"\"\"\n    line = io.readline().strip()\n    # Implementation...\n</code></pre>"},{"location":"developer-guide/contributing/#code-organization","title":"Code Organization","text":"<ul> <li>Keep functions focused and small</li> <li>Use type hints</li> <li>Avoid deep nesting (max 3-4 levels)</li> <li>Write self-documenting code</li> </ul>"},{"location":"developer-guide/contributing/#testing","title":"Testing","text":""},{"location":"developer-guide/contributing/#writing-tests","title":"Writing Tests","text":"<p>Every feature should have tests:</p> <pre><code># tests/test_new_feature.py\ndef test_new_feature():\n    \"\"\"Test description.\"\"\"\n    # Arrange\n    mesh = gmshparser.parse(\"data/test_mesh.msh\")\n\n    # Act\n    result = mesh.get_something()\n\n    # Assert\n    assert result == expected_value\n</code></pre>"},{"location":"developer-guide/contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Aim for 100% coverage on new code</li> <li>Test edge cases and error conditions</li> <li>Include integration tests for parsers</li> </ul>"},{"location":"developer-guide/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/test_helpers.py\n\n# Run specific test\npytest tests/test_helpers.py::test_get_triangles\n\n# Run with coverage\npytest --cov=gmshparser --cov-report=html\n</code></pre>"},{"location":"developer-guide/contributing/#documentation","title":"Documentation","text":""},{"location":"developer-guide/contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> <pre><code>def get_triangles(mesh: Mesh) -&gt; Tuple[List[float], List[float], List[List[int]]]:\n    \"\"\"Extract triangular elements from mesh.\n\n    Args:\n        mesh: Parsed mesh object\n\n    Returns:\n        Tuple of (X, Y, T) where:\n            X: List of x-coordinates\n            Y: List of y-coordinates\n            T: List of triangle connectivity\n\n    Example:\n        &gt;&gt;&gt; mesh = gmshparser.parse(\"mesh.msh\")\n        &gt;&gt;&gt; X, Y, T = get_triangles(mesh)\n        &gt;&gt;&gt; print(len(T))  # Number of triangles\n        42\n    \"\"\"\n    # Implementation...\n</code></pre>"},{"location":"developer-guide/contributing/#documentation-files","title":"Documentation Files","text":"<ul> <li>Update relevant <code>.md</code> files in <code>docs/</code></li> <li>Add examples to user guide</li> <li>Update API reference if needed</li> </ul>"},{"location":"developer-guide/contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n\n# Open in browser\nopen http://127.0.0.1:8000\n</code></pre>"},{"location":"developer-guide/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"developer-guide/contributing/#before-submitting","title":"Before Submitting","text":"<ul> <li>[ ] All tests pass</li> <li>[ ] Code is formatted with <code>black</code></li> <li>[ ] No <code>flake8</code> warnings</li> <li>[ ] Documentation is updated</li> <li>[ ] CHANGELOG is updated (if applicable)</li> <li>[ ] Commit messages are clear</li> </ul>"},{"location":"developer-guide/contributing/#pr-description","title":"PR Description","text":"<p>Include in your PR description:</p> <ul> <li>What: Brief description of changes</li> <li>Why: Reason for the change</li> <li>How: Implementation approach</li> <li>Testing: How you tested the changes</li> </ul>"},{"location":"developer-guide/contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated checks run (CI/CD)</li> <li>Maintainer reviews code</li> <li>Address any feedback</li> <li>Once approved, PR is merged</li> </ol>"},{"location":"developer-guide/contributing/#release-process","title":"Release Process","text":"<p>(For maintainers)</p> <ol> <li>Update version in <code>pyproject.toml</code> and <code>gmshparser/__init__.py</code></li> <li>Update CHANGELOG.md</li> <li>Create git tag: <code>git tag v0.x.0</code></li> <li>Push tag: <code>git push origin v0.x.0</code></li> <li>Build and publish: <code>poetry publish --build</code></li> </ol>"},{"location":"developer-guide/contributing/#communication","title":"Communication","text":""},{"location":"developer-guide/contributing/#contact","title":"Contact","text":"<ul> <li>Issues: GitHub Issues</li> <li>Email: ahojukka5@gmail.com</li> <li>Discussions: Use GitHub Discussions for questions</li> </ul>"},{"location":"developer-guide/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, inclusive, and constructive. We want gmshparser to be welcoming to all contributors.</p>"},{"location":"developer-guide/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>GitHub contributors page</li> <li>Release notes</li> <li>Documentation (if significant contribution)</li> </ul>"},{"location":"developer-guide/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"developer-guide/contributing/#questions","title":"Questions?","text":"<p>Don't hesitate to ask! Open an issue or send an email. We're happy to help new contributors.</p>"},{"location":"developer-guide/contributing/#thank-you","title":"Thank You","text":"<p>Your contributions make gmshparser better for everyone. Thank you for taking the time to contribute! \ud83c\udf89</p>"},{"location":"developer-guide/test-results/","title":"Test Results","text":"<p>gmshparser is thoroughly tested with real-world mesh files covering all supported MSH format versions.</p>"},{"location":"developer-guide/test-results/#test-suite-summary","title":"Test Suite Summary","text":"<p>Successfully tested with 10 different mesh files covering all supported MSH format versions (1.0, 2.0, 2.1, 2.2, 4.0, 4.1).</p> <p>Result: 10/10 files parsed successfully (100% success rate)</p>"},{"location":"developer-guide/test-results/#test-files","title":"Test Files","text":"File Version Nodes Elements Element Types Status example_mesh.msh 4.1 197 396 15, 1, 2 \u2705 complex_v1_0.msh 1.0 12 14 15, 1, 2, 3, 4 \u2705 entities_v4_1.msh 4.1 6 2 3 \u2705 mixed_v2_0.msh 2.0 8 7 15, 1, 2, 3 \u2705 physical_v2_1.msh 2.1 10 12 15, 1, 2, 4 \u2705 testmesh.msh 4.1 6 2 3 \u2705 testmesh_v1_0.msh 1.0 6 2 3 \u2705 testmesh_v2_0.msh 2.0 6 2 3 \u2705 testmesh_v2_0_flat.msh 2.0 6 2 3 \u2705 testmesh_v2_1.msh 2.1 6 2 3 \u2705"},{"location":"developer-guide/test-results/#element-types-tested","title":"Element Types Tested","text":"<p>The test suite covers elements from 0D to 3D:</p> <ul> <li>Type 15: Point (0D)</li> <li>Type 1: Line (1D)</li> <li>Type 2: Triangle (2D)</li> <li>Type 3: Quadrangle (2D)</li> <li>Type 4: Tetrahedron (3D)</li> </ul>"},{"location":"developer-guide/test-results/#version-coverage","title":"Version Coverage","text":""},{"location":"developer-guide/test-results/#msh-10-legacy-format","title":"MSH 1.0 (Legacy Format)","text":"<p>\u2705 Fully tested with 2 files</p> <p>Features verified:</p> <ul> <li><code>$NOD</code>/<code>$ENDNOD</code> sections</li> <li><code>$ELM</code>/<code>$ENDELM</code> sections</li> <li>No <code>$MeshFormat</code> section</li> <li>Format: <code>elm-number elm-type reg-phys reg-elem number-of-nodes node-list</code></li> </ul> <p>Test files:</p> <ul> <li><code>testmesh_v1_0.msh</code> - Simple quad mesh</li> <li><code>complex_v1_0.msh</code> - Mixed element types (points, lines, triangles, quads, tets)</li> </ul>"},{"location":"developer-guide/test-results/#msh-20-standard-format","title":"MSH 2.0 (Standard Format)","text":"<p>\u2705 Fully tested with 3 files</p> <p>Features verified:</p> <ul> <li><code>$MeshFormat</code> section</li> <li><code>$Nodes</code> section (flat list)</li> <li><code>$Elements</code> section with tags</li> </ul> <p>Test files:</p> <ul> <li><code>testmesh_v2_0.msh</code> - Simple quad mesh</li> <li><code>testmesh_v2_0_flat.msh</code> - Flat node list</li> <li><code>mixed_v2_0.msh</code> - Mixed element types (points, lines, triangles, quads)</li> </ul>"},{"location":"developer-guide/test-results/#msh-21-with-physical-groups","title":"MSH 2.1 (With Physical Groups)","text":"<p>\u2705 Fully tested with 2 files</p> <p>Features verified:</p> <ul> <li>All MSH 2.0 features</li> <li><code>$PhysicalNames</code> section support</li> <li>Physical group metadata</li> </ul> <p>Test files:</p> <ul> <li><code>testmesh_v2_1.msh</code> - Simple quad mesh with physical groups</li> <li><code>physical_v2_1.msh</code> - Complex physical group structure</li> </ul>"},{"location":"developer-guide/test-results/#msh-22-compatible-with-2021","title":"MSH 2.2 (Compatible with 2.0/2.1)","text":"<p>\u2705 Tested (uses same V2 parsers)</p> <p>Features verified:</p> <ul> <li>Identical structure to MSH 2.0/2.1</li> <li>Uses same V2 parsers</li> <li>Backward compatible</li> </ul>"},{"location":"developer-guide/test-results/#msh-4041-modern-format","title":"MSH 4.0/4.1 (Modern Format)","text":"<p>\u2705 Fully tested with 3 files</p> <p>Features verified:</p> <ul> <li><code>$Entities</code> section for topology</li> <li>Entity-based node organization</li> <li>Entity-based element organization</li> </ul> <p>Test files:</p> <ul> <li><code>testmesh.msh</code> - Simple quad mesh</li> <li><code>example_mesh.msh</code> - Large triangular mesh (197 nodes, 396 elements)</li> <li><code>entities_v4_1.msh</code> - Entity structure validation</li> </ul>"},{"location":"developer-guide/test-results/#parser-architecture-validation","title":"Parser Architecture Validation","text":""},{"location":"developer-guide/test-results/#1-automatic-version-detection","title":"1. Automatic Version Detection","text":"<p>\u2705 MSH 1.0: Detects <code>$NOD</code> section (no <code>$MeshFormat</code>) \u2705 MSH 2.x: Parses <code>$MeshFormat</code> version \u2705 MSH 4.x: Parses <code>$MeshFormat</code> version</p>"},{"location":"developer-guide/test-results/#2-version-specific-routing","title":"2. Version-Specific Routing","text":"<p>\u2705 Major version 1 \u2192 V1 parsers (<code>NodesParserV1</code>, <code>ElementsParserV1</code>) \u2705 Major version 2 \u2192 V2 parsers (<code>NodesParser</code>, <code>ElementsParser</code>) \u2705 Major version 4 \u2192 V4 parsers (<code>DEFAULT_PARSERS</code>)</p>"},{"location":"developer-guide/test-results/#3-parser-compatibility","title":"3. Parser Compatibility","text":"<p>\u2705 MSH 2.0, 2.1, 2.2 all use same V2 parsers \u2705 Demonstrates backward compatibility within major versions</p>"},{"location":"developer-guide/test-results/#test-coverage-metrics","title":"Test Coverage Metrics","text":""},{"location":"developer-guide/test-results/#unit-tests","title":"Unit Tests","text":"<pre><code>pytest --cov=gmshparser --cov-report=term-missing\n</code></pre> <p>Results:</p> <ul> <li>Total tests: 34 test cases</li> <li>Pass rate: 100% (34/34)</li> <li>Code coverage: 97%</li> <li>Missing lines: 21/771 (mainly error handling paths)</li> </ul>"},{"location":"developer-guide/test-results/#coverage-by-module","title":"Coverage by Module","text":"Module Statements Missed Coverage <code>__init__.py</code> 13 0 100% <code>abstract_parser.py</code> 9 0 100% <code>cli.py</code> 30 0 100% <code>element.py</code> 13 0 100% <code>element_entity.py</code> 39 0 100% <code>elements_parser.py</code> 36 0 100% <code>elements_parser_v1.py</code> 58 5 91% <code>elements_parser_v2.py</code> 62 6 90% <code>helpers.py</code> 98 1 99% <code>main_parser.py</code> 63 6 90% <code>mesh.py</code> 113 0 100% <code>mesh_format_parser.py</code> 16 0 100% <code>node.py</code> 13 0 100% <code>node_entity.py</code> 31 0 100% <code>nodes_parser.py</code> 39 0 100% <code>nodes_parser_v1.py</code> 36 0 100% <code>nodes_parser_v2.py</code> 42 1 98% <code>version_manager.py</code> 60 2 97% TOTAL 771 21 97%"},{"location":"developer-guide/test-results/#validation-commands","title":"Validation Commands","text":""},{"location":"developer-guide/test-results/#parse-all-test-files","title":"Parse All Test Files","text":"<pre><code>cd /home/juajukka/dev/gmshparser\npython3 -c \"\nimport gmshparser, glob\nfiles = glob.glob('testdata/*.msh') + glob.glob('testdata/test_from_internet/*.msh')\nfor f in sorted(files):\n    m = gmshparser.parse(f)\n    print(f'\u2713 {f}: v{m.get_version()}, {m.get_number_of_nodes()}N, {m.get_number_of_elements()}E')\n\"\n</code></pre>"},{"location":"developer-guide/test-results/#run-full-test-suite","title":"Run Full Test Suite","text":"<pre><code>poetry run pytest -xvs\n</code></pre>"},{"location":"developer-guide/test-results/#generate-coverage-report","title":"Generate Coverage Report","text":"<pre><code>poetry run pytest --cov=gmshparser --cov-report=html\nopen htmlcov/index.html\n</code></pre>"},{"location":"developer-guide/test-results/#continuous-integration","title":"Continuous Integration","text":"<p>All tests run automatically on:</p> <ul> <li>Every push to the repository</li> <li>Every pull request</li> <li>Multiple Python versions: 3.8, 3.9, 3.10, 3.11, 3.12, 3.13</li> </ul> <p>CI checks:</p> <ul> <li>\u2705 All unit tests pass</li> <li>\u2705 Code coverage \u2265 95%</li> <li>\u2705 Code formatting (black)</li> <li>\u2705 Linting (flake8)</li> </ul>"},{"location":"developer-guide/test-results/#test-data-organization","title":"Test Data Organization","text":"<p>Test mesh files are organized in the <code>testdata/</code> directory:</p> <pre><code>testdata/\n\u251c\u2500\u2500 README.md                    # Information about test data\n\u251c\u2500\u2500 simple/                      # Simple test meshes\n\u2502   \u251c\u2500\u2500 testmesh_v1_0.msh\n\u2502   \u251c\u2500\u2500 testmesh_v2_0.msh\n\u2502   \u251c\u2500\u2500 testmesh_v2_1.msh\n\u2502   \u2514\u2500\u2500 testmesh.msh            # MSH 4.1\n\u251c\u2500\u2500 complex/                     # Complex test meshes\n\u2502   \u251c\u2500\u2500 complex_v1_0.msh\n\u2502   \u251c\u2500\u2500 mixed_v2_0.msh\n\u2502   \u251c\u2500\u2500 physical_v2_1.msh\n\u2502   \u2514\u2500\u2500 entities_v4_1.msh\n\u2514\u2500\u2500 large/                       # Large meshes (Git LFS)\n    \u2514\u2500\u2500 example_mesh.msh         # 197 nodes, 396 elements\n</code></pre> <p>See testdata/README.md for more information about contributing test meshes.</p>"},{"location":"developer-guide/test-results/#conclusion","title":"Conclusion","text":"<p>gmshparser successfully parses all tested mesh files across 6 different MSH format versions, demonstrating:</p> <p>\u2705 Comprehensive version support (1.0, 2.0, 2.1, 2.2, 4.0, 4.1) \u2705 Robust format detection and routing \u2705 Backward compatibility within major versions \u2705 Support for multiple element types (0D-3D) \u2705 Handling of physical groups and entities \u2705 100% test success rate \u2705 97% code coverage \u2705 Production-ready quality</p> <p>Last updated: November 16, 2025 Test environment: Python 3.13.3, gmshparser 0.2.0</p>"},{"location":"developer-guide/testing/","title":"Testing Guide","text":"<p>This guide covers testing practices for gmshparser development.</p>"},{"location":"developer-guide/testing/#running-tests","title":"Running Tests","text":""},{"location":"developer-guide/testing/#run-all-tests","title":"Run All Tests","text":"<pre><code>pytest\n</code></pre>"},{"location":"developer-guide/testing/#run-specific-test-file","title":"Run Specific Test File","text":"<pre><code>pytest tests/test_helpers.py\n</code></pre>"},{"location":"developer-guide/testing/#run-with-coverage","title":"Run with Coverage","text":"<pre><code>pytest --cov=gmshparser --cov-report=term-missing\n</code></pre>"},{"location":"developer-guide/testing/#generate-html-coverage-report","title":"Generate HTML Coverage Report","text":"<pre><code>pytest --cov=gmshparser --cov-report=html\nopen htmlcov/index.html\n</code></pre>"},{"location":"developer-guide/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"developer-guide/testing/#test-structure","title":"Test Structure","text":"<pre><code>def test_feature_name():\n    \"\"\"Test description.\"\"\"\n    # Arrange - set up test data\n    mesh = gmshparser.parse(\"testdata/simple/testmesh.msh\")\n\n    # Act - perform action\n    result = mesh.get_nodes()\n\n    # Assert - verify expectations\n    assert len(result) &gt; 0\n</code></pre>"},{"location":"developer-guide/testing/#testing-parsers","title":"Testing Parsers","text":"<pre><code>def test_parser():\n    \"\"\"Test parser with known mesh file.\"\"\"\n    mesh = gmshparser.parse(\"testdata/simple/testmesh_v2_0.msh\")\n\n    assert mesh.get_version() == 2.0\n    assert mesh.get_number_of_nodes() == 6\n    assert mesh.get_number_of_elements() == 2\n</code></pre>"},{"location":"developer-guide/testing/#test-data","title":"Test Data","text":"<p>Test meshes are located in <code>testdata/</code>:</p> <ul> <li><code>testdata/simple/</code> - Simple meshes for unit tests</li> <li><code>testdata/complex/</code> - Complex meshes with mixed elements</li> <li><code>testdata/large/</code> - Large meshes for performance testing</li> </ul> <p>See testdata/README.md for details.</p>"},{"location":"developer-guide/testing/#coverage-goals","title":"Coverage Goals","text":"<ul> <li>Target: 95%+ coverage</li> <li>Current: 97% coverage</li> <li>All new features must include tests</li> </ul>"},{"location":"developer-guide/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests run automatically on every push via GitHub Actions.</p>"},{"location":"developer-guide/testing/#next-steps","title":"Next Steps","text":"<ul> <li>See Test Results for current test status</li> <li>Check Contributing Guide for development workflow</li> </ul>"},{"location":"developer-guide/writing-parsers/","title":"Writing Custom Parsers","text":"<p>gmshparser's modular architecture makes it easy to add custom parsers for new mesh file sections.</p>"},{"location":"developer-guide/writing-parsers/#parser-basics","title":"Parser Basics","text":"<p>Every parser must:</p> <ol> <li>Inherit from <code>AbstractParser</code></li> <li>Implement <code>get_section_name()</code> - returns the section identifier (e.g., <code>\"$PhysicalNames\"</code>)</li> <li>Implement <code>parse(mesh, io)</code> - reads from file and populates mesh</li> </ol>"},{"location":"developer-guide/writing-parsers/#simple-example","title":"Simple Example","text":"<p>Here's a parser for the <code>$PhysicalNames</code> section:</p> <pre><code>from gmshparser.abstract_parser import AbstractParser\nfrom gmshparser.mesh import Mesh\nfrom typing import TextIO\n\nclass PhysicalNamesParser(AbstractParser):\n    \"\"\"Parser for $PhysicalNames section.\"\"\"\n\n    @staticmethod\n    def get_section_name() -&gt; str:\n        return \"$PhysicalNames\"\n\n    @staticmethod\n    def parse(mesh: Mesh, io: TextIO) -&gt; None:\n        \"\"\"Parse physical names from mesh file.\n\n        Format:\n            $PhysicalNames\n            &lt;num_names&gt;\n            &lt;dimension&gt; &lt;physical_tag&gt; \"&lt;name&gt;\"\n            ...\n            $EndPhysicalNames\n        \"\"\"\n        # Read number of physical names\n        num_names = int(io.readline().strip())\n\n        # Parse each physical name\n        physical_names = {}\n        for _ in range(num_names):\n            line = io.readline().strip().split(maxsplit=2)\n            dimension = int(line[0])\n            tag = int(line[1])\n            name = line[2].strip('\"')\n            physical_names[(dimension, tag)] = name\n\n        # Store in mesh (you'd need to add this method to Mesh)\n        mesh.set_physical_names(physical_names)\n</code></pre>"},{"location":"developer-guide/writing-parsers/#registering-your-parser","title":"Registering Your Parser","text":"<p>Add your parser to the parser registry:</p> <pre><code># In main_parser.py\nfrom gmshparser.physical_names_parser import PhysicalNamesParser\n\nDEFAULT_PARSERS = [\n    MeshFormatParser,\n    PhysicalNamesParser,  # Your custom parser\n    NodesParser,\n    ElementsParser,\n]\n</code></pre>"},{"location":"developer-guide/writing-parsers/#testing-your-parser","title":"Testing Your Parser","text":"<p>Create comprehensive tests:</p> <pre><code># tests/test_physical_names_parser.py\nimport gmshparser\n\ndef test_physical_names_parser():\n    \"\"\"Test PhysicalNames parser.\"\"\"\n    mesh = gmshparser.parse(\"testdata/physical_names.msh\")\n\n    names = mesh.get_physical_names()\n    assert (2, 1) in names\n    assert names[(2, 1)] == \"Surface1\"\n</code></pre>"},{"location":"developer-guide/writing-parsers/#advanced-example-periodic-entities","title":"Advanced Example: Periodic Entities","text":"<p>For more complex sections:</p> <pre><code>class PeriodicParser(AbstractParser):\n    \"\"\"Parser for $Periodic section (MSH 4.x).\"\"\"\n\n    @staticmethod\n    def get_section_name() -&gt; str:\n        return \"$Periodic\"\n\n    @staticmethod\n    def parse(mesh: Mesh, io: TextIO) -&gt; None:\n        \"\"\"Parse periodic entity information.\"\"\"\n        num_periodic = int(io.readline().strip())\n\n        periodic_entities = []\n        for _ in range(num_periodic):\n            line = io.readline().strip().split()\n            dimension = int(line[0])\n            slave_tag = int(line[1])\n            master_tag = int(line[2])\n\n            # Read transformation matrix (if present)\n            if len(line) &gt; 3:\n                num_values = int(line[3])\n                transform = [float(io.readline().strip()) for _ in range(num_values)]\n            else:\n                transform = None\n\n            periodic_entities.append({\n                'dimension': dimension,\n                'slave': slave_tag,\n                'master': master_tag,\n                'transform': transform\n            })\n\n        mesh.set_periodic_entities(periodic_entities)\n</code></pre>"},{"location":"developer-guide/writing-parsers/#best-practices","title":"Best Practices","text":""},{"location":"developer-guide/writing-parsers/#1-error-handling","title":"1. Error Handling","text":"<pre><code>def parse(mesh: Mesh, io: TextIO) -&gt; None:\n    try:\n        num_items = int(io.readline().strip())\n    except ValueError as e:\n        raise ValueError(f\"Invalid format in $Section: {e}\")\n\n    if num_items &lt; 0:\n        raise ValueError(f\"Invalid count: {num_items}\")\n</code></pre>"},{"location":"developer-guide/writing-parsers/#2-type-hints","title":"2. Type Hints","text":"<pre><code>from typing import TextIO, List, Dict\n\ndef parse(mesh: Mesh, io: TextIO) -&gt; None:\n    data: Dict[int, List[float]] = {}\n    # ...\n</code></pre>"},{"location":"developer-guide/writing-parsers/#3-documentation","title":"3. Documentation","text":"<pre><code>def parse(mesh: Mesh, io: TextIO) -&gt; None:\n    \"\"\"Parse section from mesh file.\n\n    Args:\n        mesh: Mesh object to populate\n        io: File handle positioned after section header\n\n    Raises:\n        ValueError: If section format is invalid\n\n    Example:\n        Format in file:\n            $SectionName\n            &lt;data&gt;\n            $EndSectionName\n    \"\"\"\n</code></pre>"},{"location":"developer-guide/writing-parsers/#4-dont-read-the-end-marker","title":"4. Don't Read the End Marker","text":"<p>The <code>MainParser</code> handles <code>$End*</code> markers. Your parser should stop before it:</p> <pre><code># \u2705 Correct\ndef parse(mesh: Mesh, io: TextIO) -&gt; None:\n    count = int(io.readline())\n    for _ in range(count):\n        line = io.readline()\n        # Process line\n    # Stop here - don't read $EndSection\n\n# \u274c Incorrect\ndef parse(mesh: Mesh, io: TextIO) -&gt; None:\n    count = int(io.readline())\n    for _ in range(count):\n        line = io.readline()\n    end_marker = io.readline()  # Don't do this!\n</code></pre>"},{"location":"developer-guide/writing-parsers/#version-specific-parsers","title":"Version-Specific Parsers","text":"<p>For sections that differ between versions, use version checks:</p> <pre><code>def parse(mesh: Mesh, io: TextIO) -&gt; None:\n    version = mesh.get_version()\n\n    if version &lt; 2.0:\n        parse_v1_format(mesh, io)\n    elif version &lt; 4.0:\n        parse_v2_format(mesh, io)\n    else:\n        parse_v4_format(mesh, io)\n</code></pre> <p>Or create separate parser classes:</p> <pre><code>class NodeDataParserV2(AbstractParser):\n    @staticmethod\n    def get_section_name() -&gt; str:\n        return \"$NodeData\"\n\n    @staticmethod\n    def parse(mesh: Mesh, io: TextIO) -&gt; None:\n        # V2 format parsing\n        pass\n\nclass NodeDataParserV4(AbstractParser):\n    @staticmethod\n    def get_section_name() -&gt; str:\n        return \"$NodeData\"\n\n    @staticmethod\n    def parse(mesh: Mesh, io: TextIO) -&gt; None:\n        # V4 format parsing\n        pass\n</code></pre>"},{"location":"developer-guide/writing-parsers/#modifying-the-mesh-class","title":"Modifying the Mesh Class","text":"<p>If your parser needs to store new data:</p> <pre><code># In mesh.py\nclass Mesh:\n    def __init__(self):\n        # ... existing fields\n        self._physical_names = {}\n\n    def set_physical_names(self, names: Dict[Tuple[int, int], str]) -&gt; None:\n        \"\"\"Set physical group names.\"\"\"\n        self._physical_names = names\n\n    def get_physical_names(self) -&gt; Dict[Tuple[int, int], str]:\n        \"\"\"Get physical group names.\"\"\"\n        return self._physical_names\n\n    def get_physical_name(self, dimension: int, tag: int) -&gt; str:\n        \"\"\"Get physical name by dimension and tag.\"\"\"\n        return self._physical_names.get((dimension, tag), \"\")\n</code></pre>"},{"location":"developer-guide/writing-parsers/#complete-example-nodedata-parser","title":"Complete Example: NodeData Parser","text":"<pre><code>from gmshparser.abstract_parser import AbstractParser\nfrom gmshparser.mesh import Mesh\nfrom typing import TextIO, List, Dict\n\nclass NodeDataParser(AbstractParser):\n    \"\"\"Parser for $NodeData section (post-processing data).\"\"\"\n\n    @staticmethod\n    def get_section_name() -&gt; str:\n        return \"$NodeData\"\n\n    @staticmethod\n    def parse(mesh: Mesh, io: TextIO) -&gt; None:\n        \"\"\"Parse node data for visualization.\n\n        Format (MSH 2.x):\n            $NodeData\n            &lt;num_string_tags&gt;\n            \"&lt;view_name&gt;\"\n            &lt;num_real_tags&gt;\n            &lt;time_value&gt;\n            &lt;num_integer_tags&gt;\n            &lt;time_step&gt;\n            &lt;num_components&gt;\n            &lt;num_nodes&gt;\n            &lt;node_tag&gt; &lt;value1&gt; [&lt;value2&gt; ...]\n            ...\n            $EndNodeData\n        \"\"\"\n        # String tags\n        num_string_tags = int(io.readline().strip())\n        string_tags = [io.readline().strip().strip('\"') for _ in range(num_string_tags)]\n        view_name = string_tags[0] if string_tags else \"Unnamed\"\n\n        # Real tags\n        num_real_tags = int(io.readline().strip())\n        real_tags = [float(io.readline().strip()) for _ in range(num_real_tags)]\n        time_value = real_tags[0] if real_tags else 0.0\n\n        # Integer tags\n        num_integer_tags = int(io.readline().strip())\n        integer_tags = [int(io.readline().strip()) for _ in range(num_integer_tags)]\n        time_step = integer_tags[0] if len(integer_tags) &gt; 0 else 0\n        num_components = integer_tags[1] if len(integer_tags) &gt; 1 else 1\n        num_nodes = integer_tags[2] if len(integer_tags) &gt; 2 else 0\n\n        # Node data\n        node_data: Dict[int, List[float]] = {}\n        for _ in range(num_nodes):\n            parts = io.readline().strip().split()\n            node_tag = int(parts[0])\n            values = [float(v) for v in parts[1:]]\n            node_data[node_tag] = values\n\n        # Store in mesh\n        mesh.add_node_data(view_name, {\n            'time': time_value,\n            'time_step': time_step,\n            'components': num_components,\n            'data': node_data\n        })\n</code></pre>"},{"location":"developer-guide/writing-parsers/#debugging-tips","title":"Debugging Tips","text":""},{"location":"developer-guide/writing-parsers/#1-print-debug-info","title":"1. Print Debug Info","text":"<pre><code>def parse(mesh: Mesh, io: TextIO) -&gt; None:\n    position = io.tell()\n    print(f\"Parsing at position {position}\")\n    line = io.readline()\n    print(f\"Read line: {line}\")\n</code></pre>"},{"location":"developer-guide/writing-parsers/#2-validate-input","title":"2. Validate Input","text":"<pre><code>def parse(mesh: Mesh, io: TextIO) -&gt; None:\n    line = io.readline().strip()\n    parts = line.split()\n\n    if len(parts) &lt; 3:\n        raise ValueError(f\"Expected at least 3 values, got {len(parts)}: {line}\")\n</code></pre>"},{"location":"developer-guide/writing-parsers/#3-test-with-simple-files","title":"3. Test with Simple Files","text":"<p>Create minimal test files:</p> <pre><code>$MeshFormat\n4.1 0 8\n$EndMeshFormat\n$YourSection\n1\ntest data\n$EndYourSection\n</code></pre>"},{"location":"developer-guide/writing-parsers/#contributing-your-parser","title":"Contributing Your Parser","text":"<p>If you've written a useful parser:</p> <ol> <li>Add tests</li> <li>Update documentation</li> <li>Submit a pull request</li> </ol> <p>See Contributing Guide for details.</p>"},{"location":"developer-guide/writing-parsers/#next-steps","title":"Next Steps","text":"<ul> <li>Review Architecture for system overview</li> <li>Check Testing Guide for test practices</li> <li>See API Reference for existing parsers</li> </ul>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the fundamental usage patterns of gmshparser.</p>"},{"location":"user-guide/basic-usage/#parsing-a-mesh-file","title":"Parsing a Mesh File","text":"<p>The primary function you'll use is <code>gmshparser.parse()</code>:</p> <pre><code>import gmshparser\n\nmesh = gmshparser.parse(\"path/to/mesh.msh\")\n</code></pre> <p>This automatically detects the file format version and returns a <code>Mesh</code> object.</p>"},{"location":"user-guide/basic-usage/#mesh-information","title":"Mesh Information","text":"<p>After parsing, you can query basic mesh information:</p> <pre><code># Get mesh metadata\nprint(f\"Mesh name: {mesh.get_name()}\")\nprint(f\"Mesh version: {mesh.get_version()}\")\nprint(f\"Number of nodes: {mesh.get_number_of_nodes()}\")\nprint(f\"Number of elements: {mesh.get_number_of_elements()}\")\n\n# Get node tag ranges\nprint(f\"Min node tag: {mesh.get_min_node_tag()}\")\nprint(f\"Max node tag: {mesh.get_max_node_tag()}\")\n\n# Get element tag ranges\nprint(f\"Min element tag: {mesh.get_min_element_tag()}\")\nprint(f\"Max element tag: {mesh.get_max_element_tag()}\")\n\n# Get entity counts\nprint(f\"Node entities: {mesh.get_number_of_node_entities()}\")\nprint(f\"Element entities: {mesh.get_number_of_element_entities()}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-nodes","title":"Working with Nodes","text":"<p>Nodes in gmshparser are organized by entities. Here's how to access them:</p>"},{"location":"user-guide/basic-usage/#iterate-all-nodes","title":"Iterate All Nodes","text":"<pre><code>for entity in mesh.get_node_entities():\n    for node in entity.get_nodes():\n        node_id = node.get_tag()\n        coords = node.get_coordinates()\n        x, y, z = coords\n        print(f\"Node {node_id}: ({x}, {y}, {z})\")\n</code></pre>"},{"location":"user-guide/basic-usage/#get-specific-node-data","title":"Get Specific Node Data","text":"<pre><code># Get all nodes from first entity\nfirst_entity = mesh.get_node_entities()[0]\nnodes = first_entity.get_nodes()\n\n# Access node properties\nfor node in nodes:\n    tag = node.get_tag()          # Node ID\n    coords = node.get_coordinates()  # (x, y, z) tuple\n    x = coords[0]\n    y = coords[1]\n    z = coords[2]\n</code></pre>"},{"location":"user-guide/basic-usage/#entity-information","title":"Entity Information","text":"<pre><code>for entity in mesh.get_node_entities():\n    dimension = entity.get_dimension()\n    entity_tag = entity.get_tag()\n    num_nodes = entity.get_number_of_nodes()\n    print(f\"Entity {entity_tag} (dim={dimension}): {num_nodes} nodes\")\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-elements","title":"Working with Elements","text":"<p>Elements are also organized by entities:</p>"},{"location":"user-guide/basic-usage/#iterate-all-elements","title":"Iterate All Elements","text":"<pre><code>for entity in mesh.get_element_entities():\n    element_type = entity.get_element_type()\n    print(f\"Element type: {element_type}\")\n\n    for element in entity.get_elements():\n        elem_id = element.get_tag()\n        connectivity = element.get_connectivity()\n        print(f\"Element {elem_id}: nodes {connectivity}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#element-types","title":"Element Types","text":"<p>Gmsh uses numeric codes for element types:</p> Code Element Type Nodes 15 Point 1 1 Line 2 2 Triangle 3 3 Quadrangle 4 4 Tetrahedron 4 5 Hexahedron 8 8 Line (3-node) 3 9 Triangle (6-node) 6 ... ... ... <p>See the Gmsh documentation for a complete list.</p>"},{"location":"user-guide/basic-usage/#filter-elements-by-type","title":"Filter Elements by Type","text":"<pre><code># Get all triangular elements\nfor entity in mesh.get_element_entities():\n    if entity.get_element_type() == 2:  # Triangle\n        for element in entity.get_elements():\n            print(f\"Triangle {element.get_tag()}: {element.get_connectivity()}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#using-helper-functions","title":"Using Helper Functions","text":"<p>gmshparser provides helper functions for common tasks:</p>"},{"location":"user-guide/basic-usage/#extract-triangles-for-plotting","title":"Extract Triangles for Plotting","text":"<pre><code>from gmshparser.helpers import get_triangles\n\nmesh = gmshparser.parse(\"mesh.msh\")\nX, Y, T = get_triangles(mesh)\n\n# X, Y: coordinate arrays\n# T: connectivity array for matplotlib.triplot\n</code></pre>"},{"location":"user-guide/basic-usage/#extract-quadrilaterals","title":"Extract Quadrilaterals","text":"<pre><code>from gmshparser.helpers import get_quads\n\nmesh = gmshparser.parse(\"mesh.msh\")\nX, Y, Q = get_quads(mesh)\n\n# Q: quadrilateral connectivity array\n</code></pre>"},{"location":"user-guide/basic-usage/#extract-all-2d-elements","title":"Extract All 2D Elements","text":"<pre><code>from gmshparser.helpers import get_elements_2d\n\nmesh = gmshparser.parse(\"mesh.msh\")\nX, Y, triangles, quads = get_elements_2d(mesh)\n\n# Returns both triangles and quads\n</code></pre>"},{"location":"user-guide/basic-usage/#practical-examples","title":"Practical Examples","text":""},{"location":"user-guide/basic-usage/#example-1-export-nodes-to-csv","title":"Example 1: Export Nodes to CSV","text":"<pre><code>import gmshparser\nimport csv\n\nmesh = gmshparser.parse(\"mesh.msh\")\n\nwith open(\"nodes.csv\", \"w\", newline=\"\") as f:\n    writer = csv.writer(f)\n    writer.writerow([\"ID\", \"X\", \"Y\", \"Z\"])\n\n    for entity in mesh.get_node_entities():\n        for node in entity.get_nodes():\n            tag = node.get_tag()\n            x, y, z = node.get_coordinates()\n            writer.writerow([tag, x, y, z])\n</code></pre>"},{"location":"user-guide/basic-usage/#example-2-count-element-types","title":"Example 2: Count Element Types","text":"<pre><code>import gmshparser\nfrom collections import Counter\n\nmesh = gmshparser.parse(\"mesh.msh\")\n\nelement_types = Counter()\nfor entity in mesh.get_element_entities():\n    elem_type = entity.get_element_type()\n    elem_count = entity.get_number_of_elements()\n    element_types[elem_type] += elem_count\n\nfor elem_type, count in element_types.items():\n    print(f\"Type {elem_type}: {count} elements\")\n</code></pre>"},{"location":"user-guide/basic-usage/#example-3-build-a-connectivity-matrix","title":"Example 3: Build a Connectivity Matrix","text":"<pre><code>import gmshparser\nimport numpy as np\n\nmesh = gmshparser.parse(\"mesh.msh\")\n\n# Collect all triangular elements\ntriangles = []\nfor entity in mesh.get_element_entities():\n    if entity.get_element_type() == 2:  # Triangle\n        for element in entity.get_elements():\n            triangles.append(element.get_connectivity())\n\n# Convert to numpy array\nconnectivity = np.array(triangles)\nprint(f\"Triangle connectivity shape: {connectivity.shape}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-different-msh-versions","title":"Working with Different MSH Versions","text":"<p>gmshparser handles version differences automatically:</p> <pre><code># Works with any supported version (1.0, 2.0, 2.1, 2.2, 4.0, 4.1)\nmesh = gmshparser.parse(\"any_version.msh\")\n\n# Check which version was detected\nversion = mesh.get_version()\nprint(f\"Detected MSH version: {version}\")\n</code></pre> <p>The API remains consistent regardless of the file format version.</p>"},{"location":"user-guide/basic-usage/#error-handling","title":"Error Handling","text":"<p>Handle parsing errors gracefully:</p> <pre><code>import gmshparser\n\ntry:\n    mesh = gmshparser.parse(\"mesh.msh\")\nexcept FileNotFoundError:\n    print(\"Mesh file not found\")\nexcept Exception as e:\n    print(f\"Error parsing mesh: {e}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about the Command Line Interface</li> <li>Explore Visualization options</li> <li>Check the API Reference</li> </ul>"},{"location":"user-guide/cli/","title":"Command Line Interface","text":"<p>gmshparser includes a command-line interface (CLI) for quick mesh inspection and data extraction without writing Python code.</p>"},{"location":"user-guide/cli/#basic-usage","title":"Basic Usage","text":"<p>After installing gmshparser, the <code>gmshparser</code> command is available in your terminal:</p> <pre><code>gmshparser &lt;mesh_file&gt; &lt;command&gt;\n</code></pre>"},{"location":"user-guide/cli/#available-commands","title":"Available Commands","text":""},{"location":"user-guide/cli/#nodes-extract-node-data","title":"<code>nodes</code> - Extract Node Data","text":"<p>Extract all nodes in a simple format:</p> <pre><code>gmshparser mesh.msh nodes\n</code></pre> <p>Output format:</p> <pre><code>&lt;number_of_nodes&gt;\n&lt;node_id&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;\n&lt;node_id&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;\n...\n</code></pre> <p>Example:</p> <pre><code>$ gmshparser data/testmesh.msh nodes\n6\n1 0.000000 0.000000 0.000000\n2 1.000000 0.000000 0.000000\n3 1.000000 1.000000 0.000000\n4 0.000000 1.000000 0.000000\n5 2.000000 0.000000 0.000000\n6 2.000000 1.000000 0.000000\n</code></pre>"},{"location":"user-guide/cli/#elements-extract-element-data","title":"<code>elements</code> - Extract Element Data","text":"<p>Extract all elements with their connectivity:</p> <pre><code>gmshparser mesh.msh elements\n</code></pre> <p>Output format:</p> <pre><code>&lt;number_of_elements&gt;\n&lt;element_id&gt; &lt;element_type&gt; &lt;node_1&gt; &lt;node_2&gt; ... &lt;node_n&gt;\n&lt;element_id&gt; &lt;element_type&gt; &lt;node_1&gt; &lt;node_2&gt; ... &lt;node_n&gt;\n...\n</code></pre> <p>Example:</p> <pre><code>$ gmshparser data/testmesh.msh elements\n2\n1 3 1 2 3 4\n2 3 2 5 6 3\n</code></pre>"},{"location":"user-guide/cli/#practical-use-cases","title":"Practical Use Cases","text":""},{"location":"user-guide/cli/#1-quick-mesh-inspection","title":"1. Quick Mesh Inspection","text":"<p>Check mesh contents without writing code:</p> <pre><code># Count nodes\ngmshparser mesh.msh nodes | wc -l\n\n# Count elements\ngmshparser mesh.msh elements | wc -l\n\n# View first 10 nodes\ngmshparser mesh.msh nodes | head -n 11\n</code></pre>"},{"location":"user-guide/cli/#2-import-to-other-languages","title":"2. Import to Other Languages","text":"<p>The simple output format makes it easy to read mesh data in C, C++, Fortran, or other languages:</p> <p>C++ Example:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\nint main() {\n    std::ifstream nodes(\"nodes.txt\");\n    int num_nodes;\n    nodes &gt;&gt; num_nodes;\n\n    for (int i = 0; i &lt; num_nodes; ++i) {\n        int id;\n        double x, y, z;\n        nodes &gt;&gt; id &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        std::cout &lt;&lt; \"Node \" &lt;&lt; id &lt;&lt; \": (\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \", \" &lt;&lt; z &lt;&lt; \")\\n\";\n    }\n\n    return 0;\n}\n</code></pre> <p>Fortran Example:</p> <pre><code>program read_mesh\n    implicit none\n    integer :: num_nodes, i, node_id\n    real(8) :: x, y, z\n\n    open(unit=10, file='nodes.txt', status='old')\n    read(10, *) num_nodes\n\n    do i = 1, num_nodes\n        read(10, *) node_id, x, y, z\n        write(*, '(A,I0,A,3F12.6)') 'Node ', node_id, ': ', x, y, z\n    end do\n\n    close(10)\nend program read_mesh\n</code></pre>"},{"location":"user-guide/cli/#3-pipeline-processing","title":"3. Pipeline Processing","text":"<p>Combine with shell tools for data processing:</p> <pre><code># Extract nodes and save to file\ngmshparser mesh.msh nodes &gt; nodes.txt\n\n# Extract elements and save to file\ngmshparser mesh.msh elements &gt; elements.txt\n\n# Extract only node coordinates (skip IDs)\ngmshparser mesh.msh nodes | tail -n +2 | awk '{print $2, $3, $4}'\n\n# Count triangular elements (type 2)\ngmshparser mesh.msh elements | grep \"^[0-9]* 2 \" | wc -l\n</code></pre>"},{"location":"user-guide/cli/#4-batch-processing","title":"4. Batch Processing","text":"<p>Process multiple meshes:</p> <pre><code>#!/bin/bash\nfor mesh in *.msh; do\n    echo \"Processing $mesh\"\n    gmshparser \"$mesh\" nodes &gt; \"${mesh%.msh}_nodes.txt\"\n    gmshparser \"$mesh\" elements &gt; \"${mesh%.msh}_elements.txt\"\ndone\n</code></pre>"},{"location":"user-guide/cli/#5-data-validation","title":"5. Data Validation","text":"<p>Quickly check mesh integrity:</p> <pre><code># Check if mesh has nodes\nif [ $(gmshparser mesh.msh nodes | head -n 1) -gt 0 ]; then\n    echo \"Mesh has nodes\"\nelse\n    echo \"Warning: Empty mesh\"\nfi\n\n# Count element types\necho \"Element type distribution:\"\ngmshparser mesh.msh elements | tail -n +2 | awk '{print $2}' | sort | uniq -c\n</code></pre>"},{"location":"user-guide/cli/#getting-help","title":"Getting Help","text":"<p>Display CLI help:</p> <pre><code>gmshparser --help\n</code></pre> <p>Or check the version:</p> <pre><code>gmshparser --version\n</code></pre>"},{"location":"user-guide/cli/#output-redirection","title":"Output Redirection","text":"<p>Save output to files:</p> <pre><code># Save nodes\ngmshparser mesh.msh nodes &gt; mesh_nodes.txt\n\n# Save elements\ngmshparser mesh.msh elements &gt; mesh_elements.txt\n\n# Append to existing file\ngmshparser mesh.msh nodes &gt;&gt; all_nodes.txt\n</code></pre>"},{"location":"user-guide/cli/#error-handling","title":"Error Handling","text":"<p>The CLI provides clear error messages:</p> <pre><code>$ gmshparser nonexistent.msh nodes\nError: File 'nonexistent.msh' not found\n\n$ gmshparser mesh.msh invalid_command\nError: Unknown command 'invalid_command'\nValid commands: nodes, elements\n</code></pre>"},{"location":"user-guide/cli/#performance","title":"Performance","text":"<p>The CLI is optimized for quick extraction:</p> <ul> <li>Small meshes (&lt; 10K nodes): Instant</li> <li>Medium meshes (10K-100K nodes): &lt; 1 second</li> <li>Large meshes (&gt; 100K nodes): Few seconds</li> </ul>"},{"location":"user-guide/cli/#limitations","title":"Limitations","text":"<ul> <li>No filtering options (use shell tools like <code>grep</code>, <code>awk</code>)</li> <li>Fixed output format (for flexibility, use the Python API)</li> <li>No mesh modification (CLI is read-only)</li> </ul> <p>For more complex operations, use the Python API.</p>"},{"location":"user-guide/cli/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Visualization</li> <li>Explore the Python API</li> <li>Check Supported Formats</li> </ul>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>Welcome to gmshparser! This guide will help you get started with parsing Gmsh mesh files in Python.</p>"},{"location":"user-guide/getting-started/#what-is-gmshparser","title":"What is gmshparser?","text":"<p>gmshparser is a lightweight Python library for reading Gmsh <code>.msh</code> files. It focuses on doing one thing well: parsing mesh files with a clean, simple API.</p>"},{"location":"user-guide/getting-started/#why-gmshparser","title":"Why gmshparser?","text":"<ul> <li>No external dependencies: Pure Python implementation</li> <li>Universal format support: Works with MSH 1.0 through 4.1</li> <li>Automatic detection: Detects file format version automatically</li> <li>Well tested: 100% test coverage with 34+ test cases</li> <li>Easy to use: Simple, intuitive API</li> </ul>"},{"location":"user-guide/getting-started/#what-can-you-do-with-gmshparser","title":"What can you do with gmshparser?","text":"<ul> <li>Parse Gmsh mesh files of any supported version</li> <li>Extract nodes and their coordinates</li> <li>Extract elements and their connectivity</li> <li>Access physical groups and entities</li> <li>Export mesh data for other FEM codes</li> <li>Visualize 2D meshes using matplotlib</li> </ul>"},{"location":"user-guide/getting-started/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.8.1 or later</li> <li>No external dependencies required for core functionality</li> <li>matplotlib (optional, for visualization)</li> </ul>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<ol> <li>Install gmshparser</li> <li>Learn basic usage</li> <li>Try the command-line interface</li> <li>Visualize your meshes</li> </ol>"},{"location":"user-guide/getting-started/#quick-example","title":"Quick Example","text":"<p>Here's a simple example to get you started:</p> <pre><code>import gmshparser\n\n# Parse a mesh file\nmesh = gmshparser.parse(\"my_mesh.msh\")\n\n# Print mesh information\nprint(f\"Mesh version: {mesh.get_version()}\")\nprint(f\"Number of nodes: {mesh.get_number_of_nodes()}\")\nprint(f\"Number of elements: {mesh.get_number_of_elements()}\")\n\n# Access first node\nfor entity in mesh.get_node_entities():\n    for node in entity.get_nodes():\n        print(f\"First node: {node.get_tag()} at {node.get_coordinates()}\")\n        break\n    break\n</code></pre>"},{"location":"user-guide/getting-started/#getting-help","title":"Getting Help","text":"<p>If you encounter issues or have questions:</p> <ul> <li>Check the API Reference</li> <li>Review examples in the repository</li> <li>Open an issue on GitHub</li> <li>Contact the author: ahojukka5@gmail.com</li> </ul>"},{"location":"user-guide/installation/","title":"Installation","text":""},{"location":"user-guide/installation/#install-from-pypi-recommended","title":"Install from PyPI (Recommended)","text":"<p>The easiest way to install gmshparser is from the Python Package Index (PyPI):</p> <pre><code>pip install gmshparser\n</code></pre> <p>This will install the latest stable release.</p>"},{"location":"user-guide/installation/#install-from-github-development-version","title":"Install from GitHub (Development Version)","text":"<p>To install the latest development version directly from GitHub:</p> <pre><code>pip install git+https://github.com/ahojukka5/gmshparser.git\n</code></pre>"},{"location":"user-guide/installation/#install-with-poetry","title":"Install with Poetry","text":"<p>If you're using Poetry for dependency management:</p> <pre><code>poetry add gmshparser\n</code></pre>"},{"location":"user-guide/installation/#install-with-optional-dependencies","title":"Install with Optional Dependencies","text":"<p>If you want visualization support with matplotlib:</p> <pre><code>pip install gmshparser matplotlib\n</code></pre>"},{"location":"user-guide/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that gmshparser is working correctly:</p> <pre><code>import gmshparser\nprint(gmshparser.__version__)\n</code></pre> <p>Or test the command-line interface:</p> <pre><code>gmshparser --help\n</code></pre>"},{"location":"user-guide/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to gmshparser, clone the repository and install in development mode:</p> <pre><code># Clone the repository\ngit clone https://github.com/ahojukka5/gmshparser.git\ncd gmshparser\n\n# Install with Poetry (recommended)\npoetry install\n\n# Or install with pip in editable mode\npip install -e .\n</code></pre>"},{"location":"user-guide/installation/#system-requirements","title":"System Requirements","text":""},{"location":"user-guide/installation/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Python 3.8.1 or later</li> <li>pip or Poetry</li> </ul>"},{"location":"user-guide/installation/#recommended-setup","title":"Recommended Setup","text":"<ul> <li>Python 3.10 or later</li> <li>Virtual environment (venv, conda, or Poetry)</li> </ul>"},{"location":"user-guide/installation/#optional-dependencies","title":"Optional Dependencies","text":"<ul> <li>matplotlib (&gt;=3.5, &lt;3.11): For mesh visualization</li> <li>mkdocs (&gt;=1.6): For building documentation (development only)</li> </ul>"},{"location":"user-guide/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/installation/#python-version-issues","title":"Python Version Issues","text":"<p>If you see errors about Python version, ensure you're using Python 3.8.1 or later:</p> <pre><code>python --version\n</code></pre>"},{"location":"user-guide/installation/#permission-errors","title":"Permission Errors","text":"<p>If you encounter permission errors during installation, try:</p> <pre><code>pip install --user gmshparser\n</code></pre> <p>Or use a virtual environment (recommended):</p> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install gmshparser\n</code></pre>"},{"location":"user-guide/installation/#import-errors","title":"Import Errors","text":"<p>If you can install but can't import the package, check that you're using the correct Python environment:</p> <pre><code>which python\nwhich pip\n</code></pre>"},{"location":"user-guide/installation/#upgrading","title":"Upgrading","text":"<p>To upgrade to the latest version:</p> <pre><code>pip install --upgrade gmshparser\n</code></pre>"},{"location":"user-guide/installation/#uninstalling","title":"Uninstalling","text":"<p>To remove gmshparser:</p> <pre><code>pip uninstall gmshparser\n</code></pre>"},{"location":"user-guide/supported-formats/","title":"Supported Formats","text":"<p>gmshparser supports multiple versions of the Gmsh MSH file format, automatically detecting the version and using the appropriate parser.</p>"},{"location":"user-guide/supported-formats/#format-overview","title":"Format Overview","text":"Version Status Description MSH 1.0 \u2705 Fully Supported Legacy format MSH 2.0 \u2705 Fully Supported Standard format MSH 2.1 \u2705 Fully Supported With physical names MSH 2.2 \u2705 Fully Supported Compatible with 2.0/2.1 MSH 4.0 \u2705 Fully Supported Modern entity-based format MSH 4.1 \u2705 Fully Supported Latest version"},{"location":"user-guide/supported-formats/#msh-10-legacy-format","title":"MSH 1.0 (Legacy Format)","text":"<p>The original Gmsh format using simple section markers.</p>"},{"location":"user-guide/supported-formats/#structure","title":"Structure","text":"<pre><code>$NOD\n&lt;number-of-nodes&gt;\n&lt;node-id&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;\n...\n$ENDNOD\n$ELM\n&lt;number-of-elements&gt;\n&lt;elm-number&gt; &lt;elm-type&gt; &lt;reg-phys&gt; &lt;reg-elem&gt; &lt;number-of-nodes&gt; &lt;node-list&gt;\n...\n$ENDELM\n</code></pre>"},{"location":"user-guide/supported-formats/#features","title":"Features","text":"<ul> <li>No <code>$MeshFormat</code> section</li> <li>Simple node and element sections</li> <li>Legacy element type numbering</li> <li>Physical and elementary region tags</li> </ul>"},{"location":"user-guide/supported-formats/#example","title":"Example","text":"<pre><code>$NOD\n6\n1 0.0 0.0 0.0\n2 1.0 0.0 0.0\n3 1.0 1.0 0.0\n4 0.0 1.0 0.0\n5 2.0 0.0 0.0\n6 2.0 1.0 0.0\n$ENDNOD\n$ELM\n2\n1 3 0 1 4 1 2 3 4\n2 3 0 1 4 2 5 6 3\n$ENDELM\n</code></pre>"},{"location":"user-guide/supported-formats/#msh-202122-standard-format","title":"MSH 2.0/2.1/2.2 (Standard Format)","text":"<p>The widely-used standard format with <code>$MeshFormat</code> section.</p>"},{"location":"user-guide/supported-formats/#structure_1","title":"Structure","text":"<pre><code>$MeshFormat\n&lt;version&gt; &lt;file-type&gt; &lt;data-size&gt;\n$EndMeshFormat\n$Nodes\n&lt;number-of-nodes&gt;\n&lt;node-id&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;\n...\n$EndNodes\n$Elements\n&lt;number-of-elements&gt;\n&lt;elm-id&gt; &lt;elm-type&gt; &lt;number-of-tags&gt; &lt;tag-list&gt; &lt;node-list&gt;\n...\n$EndElements\n</code></pre>"},{"location":"user-guide/supported-formats/#msh-21-addition","title":"MSH 2.1 Addition","text":"<pre><code>$PhysicalNames\n&lt;number-of-physical-names&gt;\n&lt;dimension&gt; &lt;physical-tag&gt; \"&lt;physical-name&gt;\"\n...\n$EndPhysicalNames\n</code></pre>"},{"location":"user-guide/supported-formats/#features_1","title":"Features","text":"<ul> <li>Explicit version declaration</li> <li>Node and element sections with clear syntax</li> <li>Support for element tags (physical, elementary, partition)</li> <li>Optional physical group names (2.1+)</li> <li>ASCII or binary formats supported</li> </ul>"},{"location":"user-guide/supported-formats/#example-msh-22","title":"Example (MSH 2.2)","text":"<pre><code>$MeshFormat\n2.2 0 8\n$EndMeshFormat\n$Nodes\n6\n1 0.0 0.0 0.0\n2 1.0 0.0 0.0\n3 1.0 1.0 0.0\n4 0.0 1.0 0.0\n5 2.0 0.0 0.0\n6 2.0 1.0 0.0\n$EndNodes\n$Elements\n2\n1 3 2 1 1 1 2 3 4\n2 3 2 1 1 2 5 6 3\n$EndElements\n</code></pre>"},{"location":"user-guide/supported-formats/#msh-4041-modern-format","title":"MSH 4.0/4.1 (Modern Format)","text":"<p>The current Gmsh format with entity-based organization.</p>"},{"location":"user-guide/supported-formats/#structure_2","title":"Structure","text":"<pre><code>$MeshFormat\n&lt;version&gt; &lt;file-type&gt; &lt;data-size&gt;\n$EndMeshFormat\n$Entities\n&lt;numPoints&gt; &lt;numCurves&gt; &lt;numSurfaces&gt; &lt;numVolumes&gt;\n&lt;point-entities&gt;\n&lt;curve-entities&gt;\n&lt;surface-entities&gt;\n&lt;volume-entities&gt;\n$EndEntities\n$Nodes\n&lt;numEntityBlocks&gt; &lt;numNodes&gt; &lt;minNodeTag&gt; &lt;maxNodeTag&gt;\n&lt;entityDim&gt; &lt;entityTag&gt; &lt;parametric&gt; &lt;numNodesInBlock&gt;\n&lt;nodeTag&gt;\n...\n&lt;x&gt; &lt;y&gt; &lt;z&gt;\n...\n$EndNodes\n$Elements\n&lt;numEntityBlocks&gt; &lt;numElements&gt; &lt;minElementTag&gt; &lt;maxElementTag&gt;\n&lt;entityDim&gt; &lt;entityTag&gt; &lt;elementType&gt; &lt;numElementsInBlock&gt;\n&lt;elementTag&gt; &lt;nodeTag1&gt; &lt;nodeTag2&gt; ...\n...\n$EndElements\n</code></pre>"},{"location":"user-guide/supported-formats/#features_2","title":"Features","text":"<ul> <li>Entity-based organization (points, curves, surfaces, volumes)</li> <li>Explicit entity topology</li> <li>Node and element blocks grouped by entity</li> <li>More efficient for large meshes</li> <li>Better support for high-order elements</li> </ul>"},{"location":"user-guide/supported-formats/#example-msh-41","title":"Example (MSH 4.1)","text":"<pre><code>$MeshFormat\n4.1 0 8\n$EndMeshFormat\n$Nodes\n1 6 1 6\n2 1 0 6\n1\n2\n3\n4\n5\n6\n0.0 0.0 0.0\n1.0 0.0 0.0\n1.0 1.0 0.0\n0.0 1.0 0.0\n2.0 0.0 0.0\n2.0 1.0 0.0\n$EndNodes\n$Elements\n1 2 1 2\n2 1 3 2\n1 1 2 3 4\n2 2 5 6 3\n$EndElements\n</code></pre>"},{"location":"user-guide/supported-formats/#element-types","title":"Element Types","text":"<p>All formats use the same element type numbering:</p> Type Name Nodes Dimension 1 Line 2 1D 2 Triangle 3 2D 3 Quadrangle 4 2D 4 Tetrahedron 4 3D 5 Hexahedron 8 3D 6 Prism 6 3D 7 Pyramid 5 3D 8 Line (3-node) 3 1D 9 Triangle (6-node) 6 2D 10 Quadrangle (9-node) 9 2D 11 Tetrahedron (10-node) 10 3D 15 Point 1 0D ... Higher-order elements ... ... <p>See the Gmsh documentation for the complete list.</p>"},{"location":"user-guide/supported-formats/#version-detection","title":"Version Detection","text":"<p>gmshparser automatically detects the file format version:</p> <pre><code>import gmshparser\n\nmesh = gmshparser.parse(\"mesh.msh\")\nversion = mesh.get_version()\n\nif version == 1.0:\n    print(\"Legacy MSH 1.0 format\")\nelif version &gt;= 2.0 and version &lt; 3.0:\n    print(\"Standard MSH 2.x format\")\nelif version &gt;= 4.0:\n    print(\"Modern MSH 4.x format\")\n</code></pre>"},{"location":"user-guide/supported-formats/#detection-algorithm","title":"Detection Algorithm","text":"<ol> <li>Read first line of file</li> <li>If line is <code>$MeshFormat</code>: Parse version from next line</li> <li>If line is <code>$NOD</code>: Assume MSH 1.0</li> <li>Otherwise: Error (unsupported format)</li> </ol>"},{"location":"user-guide/supported-formats/#format-compatibility","title":"Format Compatibility","text":""},{"location":"user-guide/supported-formats/#gmshparser-gmshparser","title":"gmshparser \u2192 gmshparser","text":"<p>All supported versions can be read and processed with the same API:</p> <pre><code># Same code works for all versions\nfor entity in mesh.get_node_entities():\n    for node in entity.get_nodes():\n        print(node.get_tag(), node.get_coordinates())\n</code></pre>"},{"location":"user-guide/supported-formats/#gmsh-gmshparser","title":"Gmsh \u2192 gmshparser","text":"<p>gmshparser can read all mesh files generated by:</p> <ul> <li>Gmsh 1.x (MSH 1.0)</li> <li>Gmsh 2.x (MSH 2.0, 2.1, 2.2)</li> <li>Gmsh 4.x (MSH 4.0, 4.1)</li> </ul>"},{"location":"user-guide/supported-formats/#limitations","title":"Limitations","text":"<ul> <li>Binary format: Not supported (ASCII only)</li> <li>Compressed format: Not supported</li> <li>Post-processing data: Node/element data sections not parsed (but can be added if needed)</li> <li>Periodic entities: Not explicitly handled</li> </ul>"},{"location":"user-guide/supported-formats/#converting-between-versions","title":"Converting Between Versions","text":"<p>To convert between formats, use Gmsh itself:</p> <pre><code># Convert to MSH 2.2\ngmsh input.msh -format msh22 -o output.msh\n\n# Convert to MSH 4.1\ngmsh input.msh -format msh41 -o output.msh\n</code></pre> <p>Or in Python with gmshparser:</p> <pre><code># Read any version\nmesh = gmshparser.parse(\"input.msh\")\n\n# Extract and rewrite (would need custom writer)\n# Note: gmshparser currently only reads, not writes\n</code></pre>"},{"location":"user-guide/supported-formats/#testing","title":"Testing","text":"<p>gmshparser is tested against real mesh files for all supported versions:</p> <ul> <li>10+ test files covering all versions</li> <li>Elements from 0D (points) to 3D (tetrahedra)</li> <li>Various mesh complexities</li> <li>100% success rate on test suite</li> </ul> <p>See the Test Results for details.</p>"},{"location":"user-guide/supported-formats/#future-support","title":"Future Support","text":"<p>Potential future additions:</p> <ul> <li>Binary format support</li> <li>Post-processing data sections</li> <li>MSH format writing (currently read-only)</li> <li>Compressed file support</li> </ul>"},{"location":"user-guide/supported-formats/#references","title":"References","text":"<ul> <li>Official Gmsh MSH Format Documentation</li> <li>Gmsh Website</li> <li>Gmsh GitLab Repository</li> </ul>"},{"location":"user-guide/supported-formats/#next-steps","title":"Next Steps","text":"<ul> <li>Try parsing different format versions</li> <li>Check the API Reference</li> <li>Learn about Writing Custom Parsers</li> </ul>"},{"location":"user-guide/visualization/","title":"Visualization","text":"<p>gmshparser includes helper functions for visualizing 2D meshes using matplotlib.</p> <p>Note</p> <p>Visualization requires matplotlib. Install it with: <pre><code>pip install matplotlib\n</code></pre></p>"},{"location":"user-guide/visualization/#quick-start","title":"Quick Start","text":"<pre><code>import gmshparser\nimport matplotlib.pyplot as plt\n\n# Parse mesh\nmesh = gmshparser.parse(\"mesh.msh\")\n\n# Extract triangle data\nX, Y, T = gmshparser.helpers.get_triangles(mesh)\n\n# Plot\nplt.triplot(X, Y, T, 'k-', linewidth=0.5)\nplt.axis('equal')\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#visualizing-triangular-meshes","title":"Visualizing Triangular Meshes","text":"<p>The <code>get_triangles()</code> helper extracts triangular elements:</p> <pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nfrom gmshparser.helpers import get_triangles\n\nmesh = gmshparser.parse(\"data/example_mesh.msh\")\nX, Y, T = get_triangles(mesh)\n\nplt.figure(figsize=(10, 8))\nplt.triplot(X, Y, T, color='black', linewidth=0.5)\nplt.title(f\"Triangular Mesh ({len(T)} triangles)\")\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\nplt.axis('equal')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.savefig(\"triangle_mesh.png\", dpi=300)\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#visualizing-quadrilateral-meshes","title":"Visualizing Quadrilateral Meshes","text":"<p>For meshes with quadrilateral elements:</p> <pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nfrom gmshparser.helpers import get_quads\n\nmesh = gmshparser.parse(\"quad_mesh.msh\")\nX, Y, Q = get_quads(mesh)\n\nfig, ax = plt.subplots(figsize=(10, 8))\n\n# Plot each quad\nfor quad in Q:\n    nodes = quad\n    x_coords = [X[n-1] for n in nodes] + [X[nodes[0]-1]]  # Close the quad\n    y_coords = [Y[n-1] for n in nodes] + [Y[nodes[0]-1]]\n    ax.plot(x_coords, y_coords, 'k-', linewidth=0.5)\n\n# Plot nodes\nax.plot(X, Y, 'ro', markersize=3, label='Nodes')\n\nax.set_title(f\"Quadrilateral Mesh ({len(Q)} quads)\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nax.axis('equal')\nax.grid(True, alpha=0.3)\nax.legend()\nplt.tight_layout()\nplt.savefig(\"quad_mesh.png\", dpi=300)\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#visualizing-mixed-meshes","title":"Visualizing Mixed Meshes","text":"<p>For meshes containing both triangles and quads:</p> <pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nfrom gmshparser.helpers import get_elements_2d\n\nmesh = gmshparser.parse(\"mixed_mesh.msh\")\nX, Y, triangles, quads = get_elements_2d(mesh)\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\n# Plot triangles\nif triangles:\n    ax.triplot(X, Y, triangles, 'b-', linewidth=0.5, label='Triangles')\n\n# Plot quads\nfor quad in quads:\n    x_coords = [X[n-1] for n in quad] + [X[quad[0]-1]]\n    y_coords = [Y[n-1] for n in quad] + [Y[quad[0]-1]]\n    ax.plot(x_coords, y_coords, 'r-', linewidth=0.5)\n\n# Add custom legend for quads\nfrom matplotlib.lines import Line2D\nhandles = [Line2D([0], [0], color='b', linewidth=0.5, label='Triangles'),\n           Line2D([0], [0], color='r', linewidth=0.5, label='Quads')]\nax.legend(handles=handles)\n\nax.set_title(f\"Mixed Mesh ({len(triangles)} triangles, {len(quads)} quads)\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\")\nax.axis('equal')\nax.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.savefig(\"mixed_mesh.png\", dpi=300)\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#advanced-plotting-options","title":"Advanced Plotting Options","text":""},{"location":"user-guide/visualization/#add-node-labels","title":"Add Node Labels","text":"<pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nfrom gmshparser.helpers import get_triangles\n\nmesh = gmshparser.parse(\"mesh.msh\")\nX, Y, T = get_triangles(mesh)\n\nfig, ax = plt.subplots(figsize=(12, 10))\nax.triplot(X, Y, T, 'k-', linewidth=0.5)\n\n# Label nodes\nfor i, (x, y) in enumerate(zip(X, Y), start=1):\n    ax.text(x, y, str(i), fontsize=8, ha='center', va='center',\n            bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.7))\n\nax.set_title(\"Mesh with Node Labels\")\nax.axis('equal')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#add-element-labels","title":"Add Element Labels","text":"<pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom gmshparser.helpers import get_triangles\n\nmesh = gmshparser.parse(\"mesh.msh\")\nX, Y, T = get_triangles(mesh)\n\nfig, ax = plt.subplots(figsize=(12, 10))\nax.triplot(X, Y, T, 'k-', linewidth=0.5)\n\n# Label elements at their centroids\nfor i, tri in enumerate(T, start=1):\n    x_center = np.mean([X[n] for n in tri])\n    y_center = np.mean([Y[n] for n in tri])\n    ax.text(x_center, y_center, str(i), fontsize=8, ha='center', va='center',\n            color='red')\n\nax.set_title(\"Mesh with Element Labels\")\nax.axis('equal')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#color-by-element-property","title":"Color by Element Property","text":"<pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom gmshparser.helpers import get_triangles\n\nmesh = gmshparser.parse(\"mesh.msh\")\nX, Y, T = get_triangles(mesh)\n\n# Create some artificial property (e.g., element area)\nareas = []\nfor tri in T:\n    x_coords = [X[n] for n in tri]\n    y_coords = [Y[n] for n in tri]\n    # Simple area calculation\n    area = 0.5 * abs((x_coords[1]-x_coords[0])*(y_coords[2]-y_coords[0]) - \n                     (x_coords[2]-x_coords[0])*(y_coords[1]-y_coords[0]))\n    areas.append(area)\n\nfig, ax = plt.subplots(figsize=(12, 10))\ntpc = ax.tripcolor(X, Y, T, facecolors=areas, edgecolors='k', linewidth=0.5)\nfig.colorbar(tpc, ax=ax, label='Element Area')\nax.set_title(\"Mesh Colored by Element Area\")\nax.axis('equal')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#exporting-figures","title":"Exporting Figures","text":""},{"location":"user-guide/visualization/#high-resolution-png","title":"High-Resolution PNG","text":"<pre><code>plt.savefig(\"mesh.png\", dpi=300, bbox_inches='tight')\n</code></pre>"},{"location":"user-guide/visualization/#vector-graphics-pdfsvg","title":"Vector Graphics (PDF/SVG)","text":"<pre><code>plt.savefig(\"mesh.pdf\", bbox_inches='tight')  # PDF\nplt.savefig(\"mesh.svg\", bbox_inches='tight')  # SVG\n</code></pre>"},{"location":"user-guide/visualization/#multiple-formats","title":"Multiple Formats","text":"<pre><code>for fmt in ['png', 'pdf', 'svg']:\n    plt.savefig(f\"mesh.{fmt}\", dpi=300, bbox_inches='tight')\n</code></pre>"},{"location":"user-guide/visualization/#complete-example-script","title":"Complete Example Script","text":"<p>Here's a complete example that creates a publication-quality figure:</p> <pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nfrom gmshparser.helpers import get_triangles\n\n# Parse mesh\nmesh = gmshparser.parse(\"data/example_mesh.msh\")\nX, Y, T = get_triangles(mesh)\n\n# Create figure with publication settings\nplt.rcParams['font.size'] = 12\nplt.rcParams['font.family'] = 'serif'\nplt.rcParams['lines.linewidth'] = 0.5\n\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot mesh\nax.triplot(X, Y, T, color='black', linewidth=0.5)\n\n# Styling\nax.set_xlabel('X coordinate [m]', fontsize=14)\nax.set_ylabel('Y coordinate [m]', fontsize=14)\nax.set_title(f'Finite Element Mesh\\n{len(T)} triangular elements', fontsize=16)\nax.axis('equal')\nax.grid(True, alpha=0.3, linestyle='--')\nax.set_axisbelow(True)\n\n# Add statistics\nstats_text = f\"Nodes: {len(X)}\\nElements: {len(T)}\"\nax.text(0.02, 0.98, stats_text, transform=ax.transAxes,\n        verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n\nplt.tight_layout()\nplt.savefig('publication_mesh.png', dpi=300, bbox_inches='tight')\nplt.savefig('publication_mesh.pdf', bbox_inches='tight')\nplt.show()\n\nprint(\"Figures saved: publication_mesh.png, publication_mesh.pdf\")\n</code></pre>"},{"location":"user-guide/visualization/#interactive-visualization","title":"Interactive Visualization","text":"<p>For interactive exploration:</p> <pre><code>import gmshparser\nimport matplotlib.pyplot as plt\nfrom gmshparser.helpers import get_triangles\n\nmesh = gmshparser.parse(\"mesh.msh\")\nX, Y, T = get_triangles(mesh)\n\nplt.figure(figsize=(12, 10))\nplt.triplot(X, Y, T, 'k-', linewidth=0.5)\nplt.axis('equal')\nplt.title(\"Interactive Mesh (use zoom/pan tools)\")\n\n# Enable interactive mode\nplt.ion()\nplt.show()\n\n# Keep window open\ninput(\"Press Enter to close...\")\n</code></pre>"},{"location":"user-guide/visualization/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/visualization/#matplotlib-not-found","title":"matplotlib Not Found","text":"<pre><code>pip install matplotlib\n</code></pre>"},{"location":"user-guide/visualization/#empty-plot","title":"Empty Plot","text":"<p>Check that your mesh contains 2D elements:</p> <pre><code>mesh = gmshparser.parse(\"mesh.msh\")\nprint(f\"Element entities: {mesh.get_number_of_element_entities()}\")\nfor entity in mesh.get_element_entities():\n    print(f\"Element type: {entity.get_element_type()}\")\n</code></pre>"},{"location":"user-guide/visualization/#memory-issues-with-large-meshes","title":"Memory Issues with Large Meshes","text":"<p>For very large meshes, plot only a subset:</p> <pre><code>X, Y, T = get_triangles(mesh)\n# Plot only first 1000 elements\nT_subset = T[:1000]\nplt.triplot(X, Y, T_subset, 'k-')\n</code></pre>"},{"location":"user-guide/visualization/#next-steps","title":"Next Steps","text":"<ul> <li>Check the API Reference for helper functions</li> <li>Learn about Supported Formats</li> <li>View example scripts</li> </ul>"}]}